<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>HashedValue (patricia-tree.PatriciaTree.HashedValue)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">patricia-tree</a> &#x00BB; <a href="../index.html">PatriciaTree</a> &#x00BB; HashedValue</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>PatriciaTree.HashedValue</span></code></h1><p>Generic implementation of <a href="../module-type-HASHED_VALUE/index.html"><code>HASHED_VALUE</code></a>. Uses <a href="https://ocaml.org/api/Hashtbl.html#VALhash"><code>Hashtbl.hash</code></a> for hashing and physical equality for equality. Note that this may lead to maps of different types having the same identifier (<a href="../MakeHashconsedMap/index.html#val-to_int"><code>MakeHashconsedMap.to_int</code></a>), see the documentation of <a href="../module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a> for details on this.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>The type of values for a hash-consed maps.</p><p>Unlike <a href="../module-type-VALUE/index.html#type-t"><code>VALUE.t</code></a>, <b>hash-consed values should be immutable</b>. Or, if they do mutate, they must not change their <a href="#val-hash"><code>hash</code></a> value, and still be equal to the same values via <a href="#val-polyeq"><code>polyeq</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hash v</code> should return an integer hash for the value <code>v</code>. It is used for <a href="../index.html#hash_consed" title="hash_consed">hash-consing</a>.</p><p>Hashing should be fast, avoid mapping too many values to the same integer and compatible with <a href="#val-polyeq"><code>polyeq</code></a> (equal values must have the same hash: <code>polyeq v1 v2 = true ==&gt; hash v1 = hash v2</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polyeq"><a href="#val-polyeq" class="anchor"></a><code><span><span class="keyword">val</span> polyeq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Polymorphic equality on values.</p><p><b>WARNING: if <code>polyeq a b</code> is true, then casting <code>b</code> to the type of <code>a</code> (and <code>a</code> to the type of <code>b</code>) must be type-safe.</b> Eg. if <code>a : t1 t</code> and <code>b : t2 t</code> yield <code>polyeq a b = true</code>, then <code>let a' : t2 t = Obj.magic a</code> and <code>let b' : t1 t = Obj.magic b</code> must be safe.</p><p>Examples of safe implementations include:</p><ul><li><p>Having a type <code>'a t</code> which doesn't depend on <code>'a</code>, in which case casting form <code>'a t</code> to <code>'b t</code> is always safe:</p><pre class="language-ocaml"><code>type _ t = foo
let cast : type a b. a t -&gt; b t = fun x -&gt; x
let polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt; x = y</code></pre></li><li><p>Using a GADT type and examining its constructors to only return <code>true</code> when the constructors are equal:</p><pre class="language-ocaml"><code>type _ t =
    | T_Int : int -&gt; int t
    | T_Bool : bool -&gt; bool t
let polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt;
    match x, y with
    | T_Int i, T_Int j -&gt; i = j (* Here type a = b = int, we can return true *)
    | T_Bool i, T_Bool j -&gt; i &amp;&amp; j (* same here, but with a = b = bool *)
    | _ -&gt; false (* never return true on heterogeneous cases. *)</code></pre></li><li><p>Using physical equality:</p><pre class="language-ocaml"><code>let polyeq a b = a == Obj.magic b</code></pre><p>While this contains an <code>Obj.magic</code>, it is still type safe (OCaml just compares the immediate values) and we can safely cast values from one type to the other if they satisfy this (since they are already physically equal).</p><p>This is the implementation used in <a href="#"><code>HashedValue</code></a>. Note however that using this function can lead to <b>identifiers no longer being unique across types</b>. They will still be unique and behave as expected within a certain type, but since some values of different types can physically equal, we may have identifer clashes:</p><pre class="language-ocaml"><code>let _ = 97 == Obj.magic 'a' (* This is true *)

module HMap = MakeHashconsedMap(Int)(HashedValue)

let m1 = HMap.singleton 5 97 (* int HMap.t *)
let m2 = HMap.singleton 5 'a' (* char HMap.t *)
let _ = HMap.to_int m1 = HMap.to_int m2 (* This is also true. *)</code></pre><p>This can cause problems if you wish to use identifiers of different map types together:</p><pre class="language-ocaml"><code> module MapOfMaps = MakeMap(struct
   type t = Any : 'a HMap.t -&gt; t
   let to_int (Any x) = Node.to_int x
 end)

let m3 = MapOfMaps.of_list [ (m1, &quot;foo&quot;); (m2, &quot;bar&quot;) ]
(* m3 has cardinal 1, the m1-&gt;foo binding has been overwritten. *)</code></pre><p>This issue does not happen with the two previous variants, since they both only return true on the same types.</p></li></ul></div></div></div></body></html>
