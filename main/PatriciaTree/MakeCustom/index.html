<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MakeCustom (patricia-tree.PatriciaTree.MakeCustom)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">patricia-tree</a> &#x00BB; <a href="../index.html">PatriciaTree</a> &#x00BB; MakeCustom</nav><header class="odoc-preamble"><h1>Module <code><span>PatriciaTree.MakeCustom</span></code></h1><p>Create a Homogeneous Map with a custom <a href="../module-type-NODE/index.html"><code>NODE</code></a>.</p></header><nav class="odoc-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-Key"><a href="#argument-1-Key" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-Key/index.html">Key</a></span><span> : <a href="../module-type-KEY/index.html">KEY</a></span></code></div></div><div class="odoc-spec"><div class="spec parameter anchored" id="argument-2-NODE"><a href="#argument-2-NODE" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-2-NODE/index.html">NODE</a></span><span> : <a href="../module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-NODE/index.html#type-key">key</a></span> = <a href="argument-1-Key/index.html#type-t">Key.t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="../module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="../index.html#type-snd">snd</a></span></span></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span><span> = <a href="argument-1-Key/index.html#type-t">Key.t</a></span></code></div><div class="spec-doc"><p>The type of keys.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'m t</span></span><span> = <span><span class="type-var">'m</span> <a href="argument-2-NODE/index.html#type-t">NODE.t</a></span></span></code></div><div class="spec-doc"><p>A map from keys to values of type 'a.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-BaseMap"><a href="#module-BaseMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="BaseMap/index.html">BaseMap</a></span><span> : 
  <a href="../module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>_ <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-key">key</a></span> = <a href="#type-key">key</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('a, 'b) <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="../index.html#type-snd">snd</a></span></span></span></code></div><div class="spec-doc"><p>Underlying basemap, for cross map/set operations</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty map.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Test if a map is empty; O(1) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-min_binding"><a href="#val-min_binding" class="anchor"></a><code><span><span class="keyword">val</span> min_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Returns the (key,value) where <code>Key.to_int key</code> is minimal (in unsigned representation of integers); O(log n) complexity.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the map is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-max_binding"><a href="#val-max_binding" class="anchor"></a><code><span><span class="keyword">val</span> max_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Returns the (key,value) where <code>Key.to_int key</code> is maximal; O(log n) complexity.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the map is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>singleton key value</code> creates a map with a single binding, O(1) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span><span class="keyword">val</span> cardinal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The size of the map</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_singleton"><a href="#val-is_singleton" class="anchor"></a><code><span><span class="keyword">val</span> is_singleton : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>is_singleton m</code> is <code>Some (k,v)</code> iff <code>m</code> is <code>singleton k v</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Return an element in the map, or raise <code>Not_found</code>, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p>Return an element in the map, or <code>None</code>, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem key map</code> returns <code>true</code> iff <code>key</code> is bound in <code>map</code>, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns a map with the element removed, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_minimum"><a href="#val-pop_minimum" class="anchor"></a><code><span><span class="keyword">val</span> pop_minimum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_minimum m</code> returns <code>None</code> if <code>is_empty m</code>, or <code>Some(key,value,m')</code> where <code>(key,value) = min_binding m</code> and <code>m' = remove m key</code>. O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_maximum"><a href="#val-pop_maximum" class="anchor"></a><code><span><span class="keyword">val</span> pop_maximum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_maximum m</code> returns <code>None</code> if <code>is_empty m</code>, or <code>Some(key,value,m')</code> where <code>(key,value) = max_binding m</code> and <code>m' = remove m key</code>. O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span><span class="keyword">val</span> insert : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>insert key f map</code> Modifies or insert an element of the map; f takes None if the value was not previously bound, and Some old where old is the previously bound value otherwise. The function preserves physical equality when possible. O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update key f map</code> Modifies, insert, or remove an element from the map; f takes None if the value was not previously bound, and Some old where old is the previously bound value otherwise. The function preserves physical equality when possible.It returns None if the element should be removed O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Unconditionally adds a value in the map (independently from whether the old value existed). O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span class="type-var">'a</span> option</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split key map</code> splits the map into:</p><ul><li>submap of <code>map</code> whose keys are smaller than <code>key</code></li><li>value associated to <code>key</code> (if present)</li><li>submap of <code>map</code> whose keys are bigger than <code>key</code> Where the order is given by <code>Key.to_int</code>.</li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on each (key,value) pair of the map, in increasing order of keys.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p>Fold on each (key,value) pair of the map, in increasing order of keys.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns the submap containing only the key-&gt;value pairs satisfying the given predicate. <code>f</code> is called in increasing number of keys</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if the predicate holds on all map bindings. Short-circuiting</p></div></div><p>In the following, the *no_share function allows taking arguments of different types (but cannot share subtrees of the map), while the default functions attempt to preserve and benefit from sharing the subtrees (using physical equality to detect sharing).</p><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f value</code>. The subtrees for which the returned value is physically the same (i.e. <code>f key value == value</code> for all the keys in the subtree) are guaranteed to be physically equal to the original subtree. O(n) complexity. <code>f</code> is called in increasing order of keys.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_no_share"><a href="#val-map_no_share" class="anchor"></a><code><span><span class="keyword">val</span> map_no_share : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_no_share f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f value</code>. O(n) complexity. <code>f</code> is called in increasing order of keys.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mapi f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f key value</code>. The subtrees for which the returned value is physically the same (i.e. <code>f key value == value</code> for all the keys in the subtree) are guaranteed to be physically equal to the original subtree. O(n) complexity. <code>f</code> is called in increasing order of keys.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_no_share"><a href="#val-mapi_no_share" class="anchor"></a><code><span><span class="keyword">val</span> mapi_no_share : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mapi_no_share f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f key value</code>. O(n) complexity. <code>f</code> is called in increasing order of keys.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map m f</code> returns a map where the <code>value</code> bound to each <code>key</code> is removed (if <code>f key value</code> returns <code>None</code>), or is replaced by <code>v</code> ((if <code>f key value</code> returns <code>Some v</code>). The subtrees for which the returned value is physically the same (i.e. <code>f key value = Some v</code> with <code>value == v</code> for all the keys in the subtree) are guaranteed to be physically equal to the original subtree. O(n) complexity. <code>f</code> is called in increasing order of keys.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_no_share"><a href="#val-filter_map_no_share" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_no_share : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map m f</code> returns a map where the <code>value</code> bound to each <code>key</code> is removed (if <code>f key value</code> returns <code>None</code>), or is replaced by <code>v</code> ((if <code>f key value</code> returns <code>Some v</code>). O(n) complexity. <code>f</code> is called in increasing order of keys.</p></div></div><p>The following functions combine two maps. It is key for the performance, when we have large maps who share common subtrees, not to visit the nodes in these subtrees. Hence, we have specialized versions of these functions that assume properties of the function parameter (reflexive relation, idempotent operation, etc.)</p><p>When we cannot enjoy these properties, our functions explicitly say so (with a nonreflexive or nonidempotent prefix). The names are a bit long, but having these names avoids using an ineffective code by default, by forcing to know and choose between the fast and slow version.</p><p>It is also important to not visit a subtree when there merging this subtree with Empty; hence we provide union and inter operations.</p><div class="odoc-spec"><div class="spec value anchored" id="val-reflexive_same_domain_for_all2"><a href="#val-reflexive_same_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> reflexive_same_domain_for_all2 : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>reflexive_same_domain_for_all2 f map1 map2</code> returns true if <code>map1</code> and <code>map2</code> have the same keys, and <code>f key value1 value2</code> returns true for each mapping pair of keys. We assume that <code>f</code> is reflexive (i.e. <code>f key value value</code> returns true) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nonreflexive_same_domain_for_all2"><a href="#val-nonreflexive_same_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> nonreflexive_same_domain_for_all2 : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>nonreflexive_same_domain_for_all2 f map1 map2</code> returns true if map1 and map2 have the same keys, and <code>f key value1 value2</code> returns true for each mapping pair of keys. The complexity is O(min(|map1|,|map2|)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reflexive_subset_domain_for_all2"><a href="#val-reflexive_subset_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> reflexive_subset_domain_for_all2 : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>reflexive_subset_domain_for_all2 f map1 map2</code> returns true if all the keys of <code>map1</code> also are in <code>map2</code>, and <code>f key (find map1
      key) (find map2 key)</code> returns <code>true</code> when both keys are present in the map. We assume that <code>f</code> is reflexive (i.e. <code>f key value
      value</code> returns true) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_union"><a href="#val-idempotent_union" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_union : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_union f map1 map2</code> returns a map whose keys is the union of the keys of <code>map1</code> and <code>map2</code>. <code>f</code> is used to combine the values a key is mapped in both maps. We assume that <code>f</code> is idempotent (i.e. <code>f key value value == value</code>) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>, and also to preserve physical equality of the subtreess in that case. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>. <code>f</code> is called in increasing order of keys. <code>f</code> is never called on physically equal values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_inter"><a href="#val-idempotent_inter" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_inter : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_inter f map1 map2</code> returns a map whose keys is the intersection of the keys of <code>map1</code> and <code>map2</code>. <code>f</code> is used to combine the values a key is mapped in both maps. We assume that <code>f</code> is idempotent (i.e. <code>f key value value == value</code>) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>, and also to preserve physical equality of the subtrees in that case. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>. <code>f</code> is called in increasing order of keys. <code>f</code> is never called on physically equal values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nonidempotent_inter_no_share"><a href="#val-nonidempotent_inter_no_share" class="anchor"></a><code><span><span class="keyword">val</span> nonidempotent_inter_no_share : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'c</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>nonidempotent_inter_no_share f map1 map2</code> returns a map whose keys is the intersection of the keys of <code>map1</code> and <code>map2</code>. <code>f</code> is used to combine the values a key is mapped in both maps. <code>f</code> does not need to be idempotent, which imply that we have to visit physically equal subtrees of <code>map1</code> and <code>map2</code>. The complexity is O(log(n)*min(|map1|,|map2|)). <code>f</code> is called in increasing order of keys. <code>f</code> is called on every shared binding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_inter_filter"><a href="#val-idempotent_inter_filter" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_inter_filter : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_inter_filter f m1 m2</code> is like <code>idempotent_inter f m1
      m2</code> (assuming idempotence, using and preserving physically equal subtrees), but it also removes the key-&gt;value bindings for which <code>f</code> returns <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slow_merge"><a href="#val-slow_merge" class="anchor"></a><code><span><span class="keyword">val</span> slow_merge : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>slow_merge f m1 m2</code> returns a map whose keys are a subset of the keys of <code>m1</code> and <code>m2</code>. The <code>f</code> function is used to combine keys, similarly to the <code>Map.merge</code> function. This funcion has to traverse all the bindings in <code>m1</code> and <code>m2</code>; its complexity is O(|m1|+|m2|). Use one of faster functions above if you can.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-disjoint"><a href="#val-disjoint" class="anchor"></a><code><span><span class="keyword">val</span> disjoint : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-WithForeign"><a href="#module-WithForeign" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WithForeign/index.html">WithForeign</a></span><span> (<a href="WithForeign/argument-1-Map2/index.html">Map2</a> : <a href="../module-type-BASE_MAP/index.html">BASE_MAP</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>_ <a href="../module-type-BASE_MAP/index.html#type-key">key</a></span> = <a href="#type-key">key</a></span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Combination with other kinds of maps.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty"><a href="#val-pretty" class="anchor"></a><code><span><span class="keyword">val</span> pretty : 
  <span><span class="optlabel">?pp_sep</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>pp_sep</code> defaults to <code>Format.pp_print_cut</code></p></div></div><p>Conversion functions</p><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_rev_seq"><a href="#val-to_rev_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span class="type-var">'a</span>)</span> list</span></span></code></div></div></div></body></html>
