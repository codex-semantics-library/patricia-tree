<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Map2 (patricia-tree.PatriciaTree.MakeCustomMap.WithForeign.Map2)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../../';
let search_urls = ['../../../../db.js','../../../../../sherlodoc.js'];
</script><script src="../../../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../../index.html">patricia-tree</a> &#x00BB; <a href="../../../index.html">PatriciaTree</a> &#x00BB; <a href="../../index.html">MakeCustomMap</a> &#x00BB; <a href="../index.html">WithForeign</a> &#x00BB; Map2</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Parameter <code><span>WithForeign.Map2</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#basic-functions">Basic functions</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#functions-on-pairs-of-maps">Functions on pairs of maps</a></li><li><a href="#conversion-functions">Conversion functions</a></li></ul></nav><div class="odoc-content"><div class="odoc-include"><details open="open"><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../../../module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>_ <a href="../../../module-type-NODE/index.html#type-key">key</a></span> = <a href="../../index.html#type-key">key</a></span></span></code></summary><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> <span>_ key</span></span><span> = <a href="../../index.html#type-key">key</a></span></code></div><div class="spec-doc"><p>The type of keys.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> <span>('key, 'map) value</span></span></code></div><div class="spec-doc"><p>The type of value, which depends on the type of the key and the type of the map.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map t</span></span></code></div><div class="spec-doc"><p>The type of the map, which is parameterized by a type.</p></div></div><h3 id="constructors:-build-values"><a href="#constructors:-build-values" class="anchor"></a>Constructors: build values</h3><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty map</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-leaf"><a href="#val-leaf" class="anchor"></a><code><span><span class="keyword">val</span> leaf : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A singleton leaf, similar to <a href="../../../module-type-BASE_MAP/index.html#val-singleton"><code>BASE_MAP.singleton</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-branch"><a href="#val-branch" class="anchor"></a><code><span><span class="keyword">val</span> branch : 
  <span><span class="label">prefix</span>:<a href="../../../index.html#type-intkey">intkey</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">branching_bit</span>:<a href="../../../index.html#type-mask">mask</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">tree0</span>:<span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">tree1</span>:<span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A branch node. <b>This shouldn't be called externally unless you know what you're doing!</b> Doing so could easily break the data structure's invariants.</p><p>When called, it assumes that:</p><ul><li>Neither <code>tree0</code> nor <code>tree1</code> should be empty.</li><li><code>branching_bit</code> should have a single bit set</li><li><code>prefix</code> should be normalized (bits below <code>branching_bit</code> set to zero)</li><li>All elements of <code>tree0</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li><li>All elements of <code>tree1</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li></ul></div></div><h3 id="destructors:-access-the-value"><a href="#destructors:-access-the-value" class="anchor"></a>Destructors: access the value</h3><div class="odoc-spec"><div class="spec type anchored" id="type-view"><a href="#type-view" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map view</span></span><span> = <span class="keyword">private</span> </span></code><ol><li id="type-view.Empty" class="def variant constructor anchored"><a href="#type-view.Empty" class="anchor"></a><code><span>| </span><span><span class="constructor">Empty</span> : <span><span class="type-var">'map</span> <a href="#type-view">view</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Can happen only at the toplevel: there is no empty interior node.</p><span class="comment-delim">*)</span></div></li><li id="type-view.Branch" class="def variant constructor anchored"><a href="#type-view.Branch" class="anchor"></a><code><span>| </span><span><span class="constructor">Branch</span> : </span><span>{</span></code><ol><li id="type-view.prefix" class="def record field anchored"><a href="#type-view.prefix" class="anchor"></a><code><span>prefix : <a href="../../../index.html#type-intkey">intkey</a>;</span></code></li><li id="type-view.branching_bit" class="def record field anchored"><a href="#type-view.branching_bit" class="anchor"></a><code><span>branching_bit : <a href="../../../index.html#type-mask">mask</a>;</span></code></li><li id="type-view.tree0" class="def record field anchored"><a href="#type-view.tree0" class="anchor"></a><code><span>tree0 : <span><span class="type-var">'map</span> <a href="#type-t">t</a></span>;</span></code></li><li id="type-view.tree1" class="def record field anchored"><a href="#type-view.tree1" class="anchor"></a><code><span>tree1 : <span><span class="type-var">'map</span> <a href="#type-t">t</a></span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'map</span> <a href="#type-view">view</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Same constraints as <a href="#val-branch"><code>branch</code></a>:</p><ul><li><code>branching_bit</code> contains only one bit set; the corresponding mask is (branching_bit - 1).</li><li><code>prefix</code> is normalized: the bits below the <code>branching_bit</code> are set to zero (i.e. <code>prefix &amp; (branching_bit - 1) = 0</code>).</li><li>All elements of <code>tree0</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li><li>All elements of <code>tree1</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li></ul><span class="comment-delim">*)</span></div></li><li id="type-view.Leaf" class="def variant constructor anchored"><a href="#type-view.Leaf" class="anchor"></a><code><span>| </span><span><span class="constructor">Leaf</span> : </span><span>{</span></code><ol><li id="type-view.key" class="def record field anchored"><a href="#type-view.key" class="anchor"></a><code><span>key : <span><span class="type-var">'key</span> <a href="#type-key">key</a></span>;</span></code></li><li id="type-view.value" class="def record field anchored"><a href="#type-view.value" class="anchor"></a><code><span>value : <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'map</span> <a href="#type-view">view</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A key -&gt; value mapping.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>This makes the map nodes accessible to the pattern matching algorithm; this corresponds 1:1 to the <a href="../../../SimpleNode/index.html"><code>SimpleNode</code></a> implementation. This just needs to be copy-and-pasted for every node type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if the map is empty. Should be constant time.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-view"><a href="#val-view" class="anchor"></a><code><span><span class="keyword">val</span> view : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-view">view</a></span></span></code></div><div class="spec-doc"><p>Convert the map to a view. Should be constant time.</p></div></div></details></div><div class="odoc-spec"><div class="spec type anchored" id="type-key_value_pair"><a href="#type-key_value_pair" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map key_value_pair</span></span><span> = </span></code><ol><li id="type-key_value_pair.KeyValue" class="def variant constructor anchored"><a href="#type-key_value_pair.KeyValue" class="anchor"></a><code><span>| </span><span><span class="constructor">KeyValue</span> : <span><span class="type-var">'a</span> <a href="#type-key">key</a></span> * <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'map</span> <a href="#type-key_value_pair">key_value_pair</a></span></span></code></li></ol></div><div class="spec-doc"><p>Existential wrapper for the <code>'a</code> parameter in a <code>'a key</code>, <code>('a,'map) value</code> pair</p></div></div><h4 id="basic-functions"><a href="#basic-functions" class="anchor"></a>Basic functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-unsigned_min_binding"><a href="#val-unsigned_min_binding" class="anchor"></a><code><span><span class="keyword">val</span> unsigned_min_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span></span></code></div><div class="spec-doc"><p><code>unsigned_min_binding m</code> is minimal binding <code>KeyValue(k,v)</code> of the map, using the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the map is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsigned_max_binding"><a href="#val-unsigned_max_binding" class="anchor"></a><code><span><span class="keyword">val</span> unsigned_max_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span></span></code></div><div class="spec-doc"><p><code>unsigned_max_binding m</code> is maximal binding <code>KeyValue(k,v)</code> of the map, using the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the map is empty</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Create a map with a single binding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span><span class="keyword">val</span> cardinal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The size of the map, O(n) complexity</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_singleton"><a href="#val-is_singleton" class="anchor"></a><code><span><span class="keyword">val</span> is_singleton : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span> option</span></span></code></div><div class="spec-doc"><p><code>is_singleton m</code> returns <code>Some(KeyValue(k,v))</code> if and only if <code>m</code> contains a unique binding <code>k-&gt;v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span></span></code></div><div class="spec-doc"><p><code>find key map</code> returns the value associated with <code>key</code> in <code>map</code> if present.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if <code>key</code> is absent from map</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> option</span></span></code></div><div class="spec-doc"><p>Same as <a href="#val-find"><code>find</code></a>, but returns <code>None</code> for Not_found</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem key map</code> returns <code>true</code> iff <code>key</code> is bound in <code>map</code>, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns a map with the element removed, O(log(n)) complexity. Returns a physically equal map if the element is absent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_unsigned_minimum"><a href="#val-pop_unsigned_minimum" class="anchor"></a><code><span><span class="keyword">val</span> pop_unsigned_minimum : <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'map</span> <a href="#type-key_value_pair">key_value_pair</a></span> * <span><span class="type-var">'map</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_unsigned_minimum m</code> returns <code>None</code> if <code>is_empty m</code>, or <code>Some(key,value,m')</code> where <code>(key,value) = unsigned_min_binding m</code> and <code>m' = remove m key</code>. Uses the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_unsigned_maximum"><a href="#val-pop_unsigned_maximum" class="anchor"></a><code><span><span class="keyword">val</span> pop_unsigned_maximum : <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'map</span> <a href="#type-key_value_pair">key_value_pair</a></span> * <span><span class="type-var">'map</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_unsigned_maximum m</code> returns <code>None</code> if <code>is_empty m</code>, or <code>Some(key,value,m')</code> where <code>(key,value) = unsigned_max_binding m</code> and <code>m' = remove m key</code>. Uses the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span><span class="keyword">val</span> insert : 
  <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>insert key f map</code> modifies or insert an element of the map; <code>f</code> takes <code>None</code> if the value was not previously bound, and <code>Some old</code> where <code>old</code> is the previously bound value otherwise. The function preserves physical equality when possible. O(log(n)) complexity. Preserves physical equality if the new value is physically equal to the old.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : 
  <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update key f map</code> modifies, insert, or remove an element from the map; <code>f</code> takes <code>None</code> if the value was not previously bound, and <code>Some old</code> where <code>old</code> is the previously bound value otherwise. The function preserves physical equality when possible. It returns None if the element should be removed O(log(n)) complexity. Preserves physical equality if the new value is physically equal to the old.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Unconditionally adds a value in the map (independently from whether the old value existed). O(log(n)) complexity. Preserves physical equality if the new value is physically equal to the old.</p></div></div><h4 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h4><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span> * <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> option</span> * <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split key map</code> splits the map into:</p><ul><li>submap of <code>map</code> whose keys are smaller than <code>key</code></li><li>value associated to <code>key</code> (if present)</li><li>submap of <code>map</code> whose keys are bigger than <code>key</code></li></ul><p>Where the order is given by the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyiter"><a href="#type-polyiter" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map polyiter</span></span><span> = </span><span>{</span></code><ol><li id="type-polyiter.f" class="def record field anchored"><a href="#type-polyiter.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span><span class="type-var">'map</span> <a href="#type-polyiter">polyiter</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f m</code> calls <code>f.f</code> on all bindings of <code>m</code>, in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyfold"><a href="#type-polyfold" class="anchor"></a><code><span><span class="keyword">type</span> <span>('acc, 'map) polyfold</span></span><span> = </span><span>{</span></code><ol><li id="type-polyfold.f" class="def record field anchored"><a href="#type-polyfold.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span><span>(<span class="type-var">'acc</span>, <span class="type-var">'map</span>)</span> <a href="#type-polyfold">polyfold</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold f m acc</code> returns <code>f.f key_n value_n (... (f.f key_1 value_1 acc))</code> where <code>(key_1, value_1) ... (key_n, value_n)</code> are the bindings of <code>m</code>, in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyfold2"><a href="#type-polyfold2" class="anchor"></a><code><span><span class="keyword">type</span> <span>('acc, 'map) polyfold2</span></span><span> = </span><span>{</span></code><ol><li id="type-polyfold2.f" class="def record field anchored"><a href="#type-polyfold2.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_on_nonequal_inter"><a href="#val-fold_on_nonequal_inter" class="anchor"></a><code><span><span class="keyword">val</span> fold_on_nonequal_inter : 
  <span><span><span>(<span class="type-var">'acc</span>, <span class="type-var">'map</span>)</span> <a href="#type-polyfold2">polyfold2</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold_on_nonequal_inter f m1 m2 acc</code> returns <code>f.f key_n value1_n value2n (... (f.f key_1 value1_1 value2_1 acc))</code> where <code>(key_1, value1_1, value2_1) ... (key_n, value1_n, value2_n)</code> are the bindings that exist in both maps (<code>m1 âˆ© m2</code>) whose values are physically different. Calls to <code>f.f</code> are performed in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <code>Key.to_int</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyfold2_union"><a href="#type-polyfold2_union" class="anchor"></a><code><span><span class="keyword">type</span> <span>('acc, 'map) polyfold2_union</span></span><span> = </span><span>{</span></code><ol><li id="type-polyfold2_union.f" class="def record field anchored"><a href="#type-polyfold2_union.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'acc</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_on_nonequal_union"><a href="#val-fold_on_nonequal_union" class="anchor"></a><code><span><span class="keyword">val</span> fold_on_nonequal_union : 
  <span><span><span>(<span class="type-var">'acc</span>, <span class="type-var">'map</span>)</span> <a href="#type-polyfold2_union">polyfold2_union</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold_on_nonequal_union f m1 m2 acc</code> returns <code>f.f key_n value1_n value2n (... (f.f key_1 value1_1 value2_1 acc))</code> where <code>(key_1, value1_1, value2_1) ... (key_n, value1_n, value2_n)</code> are the bindings that exists in either map (<code>m1 âˆª m2</code>) whose values are physically different. Calls to <code>f.f</code> are performed in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <code>Key.to_int</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polypredicate"><a href="#type-polypredicate" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map polypredicate</span></span><span> = </span><span>{</span></code><ol><li id="type-polypredicate.f" class="def record field anchored"><a href="#type-polypredicate.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span><span class="type-var">'map</span> <a href="#type-polypredicate">polypredicate</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter f m</code> returns the submap of <code>m</code> containing the bindings <code>k-&gt;v</code> such that <code>f.f k v = true</code>. <code>f.f</code> is called in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span><span class="type-var">'map</span> <a href="#type-polypredicate">polypredicate</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all f m</code> checks that <code>f</code> holds on all bindings of <code>m</code>. Short-circuiting.</p></div></div><p>In the following, the *no_share function allows taking arguments of different types (but cannot share subtrees of the map), while the default functions attempt to preserve and benefit from sharing the subtrees (using physical equality to detect sharing).</p><div class="odoc-spec"><div class="spec type anchored" id="type-polymap"><a href="#type-polymap" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2) polymap</span></span><span> = </span><span>{</span></code><ol><li id="type-polymap.f" class="def record field anchored"><a href="#type-polymap.f" class="anchor"></a><code><span>f : 'a. <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span>(<span class="type-var">'map</span>, <span class="type-var">'map</span>)</span> <a href="#type-polymap">polymap</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_no_share"><a href="#val-map_no_share" class="anchor"></a><code><span><span class="keyword">val</span> map_no_share : <span><span><span>(<span class="type-var">'map1</span>, <span class="type-var">'map2</span>)</span> <a href="#type-polymap">polymap</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map1</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map2</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f m</code> and <code>map_no_share f m</code> replace all bindings <code>(k,v)</code> by <code>(k, f.f v)</code>. Bindings are examined in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polymapi"><a href="#type-polymapi" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2) polymapi</span></span><span> = </span><span>{</span></code><ol><li id="type-polymapi.f" class="def record field anchored"><a href="#type-polymapi.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span><span>(<span class="type-var">'map</span>, <span class="type-var">'map</span>)</span> <a href="#type-polymapi">polymapi</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_no_share"><a href="#val-mapi_no_share" class="anchor"></a><code><span><span class="keyword">val</span> mapi_no_share : <span><span><span>(<span class="type-var">'map1</span>, <span class="type-var">'map2</span>)</span> <a href="#type-polymapi">polymapi</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map1</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map2</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mapi f m</code> and <code>mapi_no_share f m</code> replace all bindings <code>(k,v)</code> by <code>(k, f.f k v)</code>. Bindings are examined in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyfilter_map"><a href="#type-polyfilter_map" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2) polyfilter_map</span></span><span> = </span><span>{</span></code><ol><li id="type-polyfilter_map.f" class="def record field anchored"><a href="#type-polyfilter_map.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span> option</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span><span>(<span class="type-var">'map</span>, <span class="type-var">'map</span>)</span> <a href="#type-polyfilter_map">polyfilter_map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_no_share"><a href="#val-filter_map_no_share" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_no_share : <span><span><span>(<span class="type-var">'map1</span>, <span class="type-var">'map2</span>)</span> <a href="#type-polyfilter_map">polyfilter_map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'map1</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map2</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map m f</code> and <code>filter_map_no_share m f</code> remove the bindings <code>(k,v)</code> for which <code>f.f k v</code> is <code>None</code>, and replaces the bindings <code>(k,v)</code> for which <code>f.f k v</code> is <code>Some v'</code> by <code>(k,v')</code>. Bindings are examined in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polypretty"><a href="#type-polypretty" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map polypretty</span></span><span> = </span><span>{</span></code><ol><li id="type-polypretty.f" class="def record field anchored"><a href="#type-polypretty.f" class="anchor"></a><code><span>f : 'a. <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty"><a href="#val-pretty" class="anchor"></a><code><span><span class="keyword">val</span> pretty : 
  <span><span class="optlabel">?pp_sep</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-polypretty">polypretty</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Pretty-prints a map using the given formatter. <code>pp_sep</code> is called once between each binding, it defaults to <a href="https://v2.ocaml.org/api/Format.html#VALpp_print_cut"><code>Format.pp_print_cut</code></a>. Bindings are printed in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div><h4 id="functions-on-pairs-of-maps"><a href="#functions-on-pairs-of-maps" class="anchor"></a>Functions on pairs of maps</h4><div class="odoc-spec"><div class="spec type anchored" id="type-polysame_domain_for_all2"><a href="#type-polysame_domain_for_all2" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2) polysame_domain_for_all2</span></span><span> = </span><span>{</span></code><ol><li id="type-polysame_domain_for_all2.f" class="def record field anchored"><a href="#type-polysame_domain_for_all2.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reflexive_same_domain_for_all2"><a href="#val-reflexive_same_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> reflexive_same_domain_for_all2 : 
  <span><span><span>(<span class="type-var">'map</span>, <span class="type-var">'map</span>)</span> <a href="#type-polysame_domain_for_all2">polysame_domain_for_all2</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>reflexive_same_domain_for_all2 f m1 m2</code> is true if and only if</p><ul><li><code>m1</code> and <code>m2</code> have the same domain (set of keys)</li><li>for all bindings <code>(k, v1)</code> in <code>m1</code> and <code>(k, v2)</code> in <code>m2</code>, <code>f.f k v1 v2</code> holds</li></ul><p><b>Assumes</b> <code>f.f</code> is reflexive, i.e. <code>f.f k v v = true</code> to skip calls to equal subtrees. Calls <code>f.f</code> in ascending <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. Exits early if the domains mismatch or if <code>f.f</code> returns false.</p><p>It is useful to implement equality on maps:</p><pre class="language-ocaml"><code>let equal m1 m2 = reflexive_same_domain_for_all2
  { f = fun _ v1 v2 -&gt; Value.equal v1 v2}
  m1 m2</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nonreflexive_same_domain_for_all2"><a href="#val-nonreflexive_same_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> nonreflexive_same_domain_for_all2 : 
  <span><span><span>(<span class="type-var">'map1</span>, <span class="type-var">'map2</span>)</span> <a href="#type-polysame_domain_for_all2">polysame_domain_for_all2</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map1</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map2</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>nonreflexive_same_domain_for_all2 f m1 m2</code> is the same as <a href="#val-reflexive_same_domain_for_all2"><code>reflexive_same_domain_for_all2</code></a>, but doesn't assume <code>f.f</code> is reflexive. It thus calls <code>f.f</code> on every binding, in ascending <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. Exits early if the domains mismatch or if <code>f.f</code> returns false.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reflexive_subset_domain_for_all2"><a href="#val-reflexive_subset_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> reflexive_subset_domain_for_all2 : 
  <span><span><span>(<span class="type-var">'map</span>, <span class="type-var">'map</span>)</span> <a href="#type-polysame_domain_for_all2">polysame_domain_for_all2</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>reflexive_subset_domain_for_all2 f m1 m2</code> is true if and only if</p><ul><li><code>m1</code>'s domain is a subset of <code>m2</code>'s. (all keys defined in <code>m1</code> are also defined in <code>m2</code>)</li><li>for all bindings <code>(k, v1)</code> in <code>m1</code> and <code>(k, v2)</code> in <code>m2</code>, <code>f.f k v1 v2</code> holds</li></ul><p><b>Assumes</b> <code>f.f</code> is reflexive, i.e. <code>f.f k v v = true</code> to skip calls to equal subtrees. Calls <code>f.f</code> in ascending <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. Exits early if the domains mismatch.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyunion"><a href="#type-polyunion" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2, 'map3) polyunion</span></span><span> = </span><span>{</span></code><ol><li id="type-polyunion.f" class="def record field anchored"><a href="#type-polyunion.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map3</span>)</span> <a href="#type-value">value</a></span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_union"><a href="#val-idempotent_union" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_union : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-polyunion">polyunion</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_union f map1 map2</code> returns a map whose keys is the union of the keys of <code>map1</code> and <code>map2</code>. <code>f.f</code> is used to combine the values of keys mapped in both maps.</p><p><b>Assumes</b> <code>f.f</code> idempotent (i.e. <code>f key value value == value</code>) <code>f.f</code> is called in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. <code>f.f</code> is never called on physically equal values. Preserves physical equality as much as possible. Complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyinter"><a href="#type-polyinter" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2, 'map3) polyinter</span></span><span> = </span><span>{</span></code><ol><li id="type-polyinter.f" class="def record field anchored"><a href="#type-polyinter.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map3</span>)</span> <a href="#type-value">value</a></span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_inter"><a href="#val-idempotent_inter" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_inter : <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-polyinter">polyinter</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_inter f map1 map2</code> returns a map whose keys is the intersection of the keys of <code>map1</code> and <code>map2</code>. <code>f.f</code> is used to combine the values a key is mapped in both maps.</p><p><b>Assumes</b> <code>f.f</code> idempotent (i.e. <code>f key value value == value</code>) <code>f.f</code> is called in the <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. <code>f.f</code> is never called on physically equal values. Preserves physical equality as much as possible. Complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nonidempotent_inter_no_share"><a href="#val-nonidempotent_inter_no_share" class="anchor"></a><code><span><span class="keyword">val</span> nonidempotent_inter_no_share : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span> <a href="#type-polyinter">polyinter</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>nonidempotent_inter_no_share f map1 map2</code> is the same as <a href="#val-idempotent_inter"><code>idempotent_inter</code></a> but doesn't preverse physical equality, doesn't assume <code>f.f</code> is idempotent, and can change the type of values. <code>f.f</code> is called on every shared binding. <code>f.f</code> is called in increasing <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of keys. O(n) complexity</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyinterfilter"><a href="#type-polyinterfilter" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2, 'map3) polyinterfilter</span></span><span> = </span><span>{</span></code><ol><li id="type-polyinterfilter.f" class="def record field anchored"><a href="#type-polyinterfilter.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map3</span>)</span> <a href="#type-value">value</a></span> option</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_inter_filter"><a href="#val-idempotent_inter_filter" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_inter_filter : 
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-polyinterfilter">polyinterfilter</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_inter_filter f map1 map2</code> is the same as <a href="#val-idempotent_inter"><code>idempotent_inter</code></a> but <code>f.f</code> can return <code>None</code> to remove a binding from the resutling map.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polymerge"><a href="#type-polymerge" class="anchor"></a><code><span><span class="keyword">type</span> <span>('map1, 'map2, 'map3) polymerge</span></span><span> = </span><span>{</span></code><ol><li id="type-polymerge.f" class="def record field anchored"><a href="#type-polymerge.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map1</span>)</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map2</span>)</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'a</span>, <span class="type-var">'map3</span>)</span> <a href="#type-value">value</a></span> option</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slow_merge"><a href="#val-slow_merge" class="anchor"></a><code><span><span class="keyword">val</span> slow_merge : 
  <span><span><span>(<span class="type-var">'map1</span>, <span class="type-var">'map2</span>, <span class="type-var">'map3</span>)</span> <a href="#type-polymerge">polymerge</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map1</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'map2</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'map3</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>This is the same as <a href="https://ocaml.org/api/Map.S.html#VALmerge">Stdlib.Map.S.merge</a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-disjoint"><a href="#val-disjoint" class="anchor"></a><code><span><span class="keyword">val</span> disjoint : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>disjoint m1 m2</code> is <code>true</code> iff <code>m1</code> and <code>m2</code> have disjoint domains</p></div></div><h4 id="conversion-functions"><a href="#conversion-functions" class="anchor"></a>Conversion functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq m</code> iterates the whole map, in increasing <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_rev_seq"><a href="#val-to_rev_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_rev_seq m</code> iterates the whole map, in decreasing <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><span><span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add_seq s m</code> adds all bindings of the sequence <code>s</code> to <code>m</code> in order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_seq s</code> creates a new map from the bindings of <code>s</code>. If a key is bound multiple times in <code>s</code>, the latest binding is kept</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_list l</code> creates a new map from the bindings of <code>l</code>. If a key is bound multiple times in <code>l</code>, the latest binding is kept</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-key_value_pair">key_value_pair</a></span> list</span></span></code></div><div class="spec-doc"><p><code>to_list m</code> returns the bindings of <code>m</code> as a list, in increasing <a href="../../../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../../../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div></div></body></html>
