<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PatriciaTree (patricia-tree.PatriciaTree)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">patricia-tree</a> &#x00BB; PatriciaTree</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>PatriciaTree</span></code></h1><p>Association maps from key to values, and sets, implemented with Patricia Trees, allowing fast merge operations by making use of physical equality between subtrees; and custom implementation of tree nodes (allowing normal maps, hash-consed maps, weak key or value maps, sets, custom maps, etc.)</p><p>This is similar to OCaml's Map, except that:</p><ul><li>The required signature for keys is different, in that we require each key to be mapped to a unique integer identifier.</li><li><p>The implementation uses Patricia Tree, as described in Okasaki and Gill's 1998 paper <a href="https://www.semanticscholar.org/paper/Fast-Mergeable-Integer-Maps-Okasaki-Gill/23003be706e5f586f23dd7fa5b2a410cc91b659d"><i>Fast mergeable integer maps</i></a>, i.e. it is a space-efficient prefix trie over the big-endian representation of the key's integer identifier.</p><p>Example 5-bit patricia tree containing five numbers: 0 <code>0b0000</code>, 1 <code>0b0001</code>, 5 <code>0b0101</code> and 7 <code>0b0111</code> and -8 <code>0b1111</code>:</p><pre>                              Branch
                          (prefix=0b?___)
                          /             \
                    Branch               Leaf(-8)
                (prefix=0b0?__)          0b1111
                /             \
           Branch             Branch
       (prefix=0b000?)     (prefix=0b01?_)
         |        |          |       |
      Leaf(0)  Leaf(1)    Leaf(5)  Leaf(7)
      0b0000   0b0001     0b0101   0b0111</pre><p>The main benefit of Patricia Tree is that their representation is stable (contrary to maps, inserting nodes in any order will return the same shape), which allows different versions of a map to share more subtrees in memory, and the operations over two maps to benefit from this sharing. The functions in this library attempt to maximally preserve sharing and benefit from sharing, allowing very important improvements in complexity and running time when combining maps or sets is a frequent operation.</p></li><li>Finally, the implementation is more customizable, allowing notably (key,value) pairs or different types to be in the same map, or to choose the memory representation of the nodes of the tree.</li><li>Some operations like <a href="module-type-BASE_MAP/index.html#val-pop_unsigned_minimum" title="BASE_MAP.pop_unsigned_minimum"><code>pop_unsigned_minimum</code></a> and <a href="module-type-BASE_MAP/index.html#val-pop_unsigned_maximum" title="BASE_MAP.pop_unsigned_maximum"><code>pop_unsigned_maximum</code></a> make our Set suitable as priority queue (but remember that each element in the queue must map to a distinct integer, and that using the <a href="#val-unsigned_lt" title="unsigned_lt">unsigned order</a> means elements with negative priority are seen as greater than elements with positive ones).</li></ul></header><nav class="odoc-toc"><ul><li><a href="#nodes">Nodes</a></li><li><a href="#map-signatures">Map signatures</a><ul><li><a href="#base-map">Base map</a></li><li><a href="#heterogeneous-maps-and-sets">Heterogeneous maps and sets</a></li><li><a href="#homogeneous-maps-and-sets">Homogeneous maps and sets</a></li></ul></li><li><a href="#keys">Keys</a></li><li><a href="#values">Values</a></li><li><a href="#functors">Functors</a><ul><li><a href="#homogeneous-maps-and-sets_2">Homogeneous maps and sets</a></li><li><a href="#heterogeneous-maps-and-sets_2">Heterogeneous maps and sets</a></li><li><a href="#maps-and-sets-with-custom-nodes">Maps and sets with custom nodes</a></li><li><a href="#hash_consed">Hash-consed maps and sets</a></li></ul></li><li><a href="#node_impl">Some implementations of NODE</a><ul><li><a href="#basic-nodes">Basic nodes</a></li><li><a href="#weak-nodes">Weak nodes</a></li><li><a href="#hashconsed-nodes">Hashconsed nodes</a></li></ul></li></ul></nav><div class="odoc-content"><p>Note on complexity: in the following, n represents the size of the map when there is one (and <code>|map1|</code> is the number of elements in <code>map1</code>). The term log(n) correspond to the maximum height of the tree, which is log(n) if we assume an even distribution of numbers in the map (e.g. random distribution, or integers chosen contiguously using a counter). The worst-case height is O(min(n,64)) which is actually constant, but not really informative; log(n) corresponds to the real complexity in usual distributions.</p><div class="odoc-spec"><div class="spec value anchored" id="val-unsigned_lt"><a href="#val-unsigned_lt" class="anchor"></a><code><span><span class="keyword">val</span> unsigned_lt : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>All integers comparisons in this library are done according to their <b>unsigned representation</b>. This is the same as signed comparison for same sign integers, but all negative integers are greater than the positives. This means <code>-1</code> is the greatest possible number, and <code>0</code> is the smallest.</p><pre class="language-ocaml"><code># unsigned_lt 2 (-1);;
- bool : true
# unsigned_lt max_int min_int;;
- bool : true
# unsigned_lt 3 2;;
- bool : false
# unsigned_lt 2 3;;
- bool : true
# unsigned_lt (-2) (-3);;
- bool : false
# unsigned_lt (-4) (-3);;
- bool : true
# unsigned_lt 0 0;;
- bool : false</code></pre><p>Using this unsigned order helps avoid a bug described in <a href="https://www.cs.tufts.edu/comp/150FP/archive/jan-midtgaard/qc-patricia.pdf"><i>QuickChecking Patricia Trees</i></a> by Jan Mitgaard.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> 0.10.0</li></ul></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-intkey"><a href="#type-intkey" class="anchor"></a><code><span><span class="keyword">type</span> intkey</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>Private type used to represent prefix stored in nodes. These are integers with all bits after branching bit (included) set to zero</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-mask"><a href="#type-mask" class="anchor"></a><code><span><span class="keyword">type</span> mask</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>Private type: integers with a single bit set.</p></div></div><h2 id="nodes"><a href="#nodes" class="anchor"></a>Nodes</h2><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-NODE"><a href="#module-type-NODE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-NODE/index.html">NODE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module explains how a node is stored in memory, with functions to create and view nodes.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-NODE_WITH_ID"><a href="#module-type-NODE_WITH_ID" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-NODE_WITH_ID/index.html">NODE_WITH_ID</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Associate a unique number to each node, so they can be used as keys in sets or maps.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HASH_CONSED_NODE"><a href="#module-type-HASH_CONSED_NODE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HASH_CONSED_NODE/index.html">HASH_CONSED_NODE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Hash-consed nodes also associate a unique number to each node, Unlike <a href="module-type-NODE_WITH_ID/index.html"><code>NODE_WITH_ID</code></a>, they also check before instanciating the node whether a similar node already exists. This results in slightly slower constructors (they perform an extra hash-table lookup), but allows for constant time equality and comparison.</p></div></div><h2 id="map-signatures"><a href="#map-signatures" class="anchor"></a>Map signatures</h2><h3 id="base-map"><a href="#base-map" class="anchor"></a>Base map</h3><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-BASE_MAP"><a href="#module-type-BASE_MAP" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BASE_MAP/index.html">BASE_MAP</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Base map signature: a generic <code>'b map</code> storing bindings of <code>'a key</code> to <code>('a,'b) values</code>. All maps and set are a variation of this type, sometimes with a simplified interface.</p></div></div><h3 id="heterogeneous-maps-and-sets"><a href="#heterogeneous-maps-and-sets" class="anchor"></a>Heterogeneous maps and sets</h3><p>Maps and sets with generic keys <code>'a key</code> and values <code>('a,'b) value</code></p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_MAP"><a href="#module-type-HETEROGENEOUS_MAP" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This is the same as <a href="module-type-MAP/index.html"><code>MAP</code></a>, but with simple type <code>key</code> being replaced by type constructor <code>'a key</code> and <code>'b value</code> being replaced by <code>('a,'b) value</code>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_SET"><a href="#module-type-HETEROGENEOUS_SET" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_SET/index.html">HETEROGENEOUS_SET</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A set containing different keys, very similar to <a href="module-type-SET/index.html"><code>SET</code></a>, but with simple type <code>elt</code> being replaced by type constructor <code>'a elt</code>.</p></div></div><h3 id="homogeneous-maps-and-sets"><a href="#homogeneous-maps-and-sets" class="anchor"></a>Homogeneous maps and sets</h3><p>Same as above, but simple interfaces for non-generic keys. These are also close to the standard library's interface for sets and maps.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-SET"><a href="#module-type-SET" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SET/index.html">SET</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Signature for sets implemented using Patricia trees. Most of this interface should be shared with <a href="https://ocaml.org/api/Set.S.html"><code>Stdlib.Set.S</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-snd"><a href="#type-snd" class="anchor"></a><code><span><span class="keyword">type</span> <span>(_, 'b) snd</span></span><span> = </span></code><ol><li id="type-snd.Snd" class="def variant constructor anchored"><a href="#type-snd.Snd" class="anchor"></a><code><span>| </span><span><span class="constructor">Snd</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></li></ol></div><div class="spec-doc"><p>The typechecker struggles with forall quantification on values if they don't depend on the first parameter, this wrapping allows our code to pass typechecking by forbidding overly eager simplification. Since the type is unboxed, it doesn't introduce any performance overhead.</p><p>This is due to a bug in the typechecker, more info on <a href="https://discuss.ocaml.org/t/weird-behaviors-with-first-order-polymorphism/13783">the OCaml discourse post</a>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-MAP_WITH_VALUE"><a href="#module-type-MAP_WITH_VALUE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MAP_WITH_VALUE/index.html">MAP_WITH_VALUE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature for maps with a single type for keys and values, a <code>'a map</code> binds <code>key</code> to <code>'a value</code>. This is slightly more generic than <a href="module-type-MAP/index.html"><code>MAP</code></a>, which just binds to <code>'a</code>. It is used for maps that need to restrict their value type, namely <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-MAP"><a href="#module-type-MAP" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MAP/index.html">MAP</a></span><span> = <a href="module-type-MAP_WITH_VALUE/index.html">MAP_WITH_VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-MAP_WITH_VALUE/index.html#type-value">value</a></span> = <span class="type-var">'a</span></span></span></code></div><div class="spec-doc"><p>The signature for maps with a single type for keys and values, a <code>'a map</code> binds <code>key</code> to <code>'a</code>. Most of this interface should be shared with <a href="https://ocaml.org/api/Map.S.html"><code>Stdlib.Map.S</code></a>.</p></div></div><h2 id="keys"><a href="#keys" class="anchor"></a>Keys</h2><p>Keys are the functor arguments used to build the maps.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-KEY"><a href="#module-type-KEY" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KEY/index.html">KEY</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature of homogeneous keys (non-generic, unparameterized keys).</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cmp"><a href="#type-cmp" class="anchor"></a><code><span><span class="keyword">type</span> <span>(_, _) cmp</span></span><span> = </span></code><ol><li id="type-cmp.Eq" class="def variant constructor anchored"><a href="#type-cmp.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span> : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-cmp">cmp</a></span></span></code></li><li id="type-cmp.Diff" class="def variant constructor anchored"><a href="#type-cmp.Diff" class="anchor"></a><code><span>| </span><span><span class="constructor">Diff</span> : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-cmp">cmp</a></span></span></code></li></ol></div><div class="spec-doc"><p>To have heterogeneous keys, we must define a polymorphic equality function. Like in the homogeneous case, it should have the requirement that <code>(to_int a) = (to_int b) ==&gt; polyeq a b = Eq</code>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_KEY"><a href="#module-type-HETEROGENEOUS_KEY" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature of heterogeneous keys.</p></div></div><h2 id="values"><a href="#values" class="anchor"></a>Values</h2><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-VALUE"><a href="#module-type-VALUE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-VALUE/index.html">VALUE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Module type used for specifying custom homogeneous value types in <a href="MakeCustomMap/index.html"><code>MakeCustomMap</code></a>. For most purposes, use the provided <a href="Value/index.html"><code>Value</code></a> implementation. It sets <code>'a t = 'a</code>, which is the desired effect (maps can map to any value). This is the case in <a href="MakeMap/index.html"><code>MakeMap</code></a>. However, for maps like <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a>, it can be useful to restrict the type of values in order to implement <code>hash</code> and <code>polyeq</code> functions on values. See the <a href="module-type-HASHED_VALUE/index.html"><code>HASHED_VALUE</code></a> module type for more details.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Value"><a href="#module-Value" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Value/index.html">Value</a></span><span> : <a href="module-type-VALUE/index.html">VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-VALUE/index.html#type-t">t</a></span> = <span class="type-var">'a</span></span></span></code></div><div class="spec-doc"><p>Default implementation of <a href="module-type-VALUE/index.html"><code>VALUE</code></a>, used in <a href="MakeMap/index.html"><code>MakeMap</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_VALUE"><a href="#module-type-HETEROGENEOUS_VALUE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The module type of values, which can be heterogeneous. This can be used to specify how the type of the value depends on that of the key. If the value doesn't depend on the key type, you can use the provided default implementations <a href="HomogeneousValue/index.html"><code>HomogeneousValue</code></a> and <a href="WrappedHomogeneousValue/index.html"><code>WrappedHomogeneousValue</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-HomogeneousValue"><a href="#module-HomogeneousValue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="HomogeneousValue/index.html">HomogeneousValue</a></span><span> : <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>('a, 'map) <a href="module-type-HETEROGENEOUS_VALUE/index.html#type-t">t</a></span> = <span class="type-var">'map</span></span></span></code></div><div class="spec-doc"><p>Default implementation of <a href="module-type-HETEROGENEOUS_VALUE/index.html"><code>HETEROGENEOUS_VALUE</code></a>, to use when the type of the value in a heterogeneous map does not depend on the type of the key, only on the type of the map.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-WrappedHomogeneousValue"><a href="#module-WrappedHomogeneousValue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WrappedHomogeneousValue/index.html">WrappedHomogeneousValue</a></span><span> : 
  <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>('a, 'map) <a href="module-type-HETEROGENEOUS_VALUE/index.html#type-t">t</a></span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-snd">snd</a></span></span></span></code></div><div class="spec-doc"><p>Same as <a href="HomogeneousValue/index.html"><code>HomogeneousValue</code></a>, but uses a wrapper (unboxed) type instead of direct equality. This avoids a problem in the typechecker with overly eager simplification of aliases. More info on <a href="https://discuss.ocaml.org/t/weird-behaviors-with-first-order-polymorphism/13783">the OCaml discourse post</a>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HASHED_VALUE"><a href="#module-type-HASHED_VALUE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HASHED_VALUE/index.html">HASHED_VALUE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><a href="module-type-VALUE/index.html"><code>VALUE</code></a> parameter for <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a>, as hash-consing requires hashing and comparing values.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_HASHED_VALUE"><a href="#module-type-HETEROGENEOUS_HASHED_VALUE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_HASHED_VALUE/index.html">HETEROGENEOUS_HASHED_VALUE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>In order to build <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a>, we need to be able to hash and compare values.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-HashedValue"><a href="#module-HashedValue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="HashedValue/index.html">HashedValue</a></span><span> : <a href="module-type-HASHED_VALUE/index.html">HASHED_VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HASHED_VALUE/index.html#type-t">t</a></span> = <span class="type-var">'a</span></span></span></code></div><div class="spec-doc"><p>Generic implementation of <a href="module-type-HASHED_VALUE/index.html"><code>HASHED_VALUE</code></a>. Uses <a href="https://ocaml.org/api/Hashtbl.html#VALhash"><code>Hashtbl.hash</code></a> for hashing and physical equality for equality. Note that this may lead to maps of different types having the same identifier (<a href="MakeHashconsedMap/index.html#val-to_int"><code>MakeHashconsedMap.to_int</code></a>), see the documentation of <a href="module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a> for details on this.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-HeterogeneousHashedValue"><a href="#module-HeterogeneousHashedValue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="HeterogeneousHashedValue/index.html">HeterogeneousHashedValue</a></span><span> : 
  <a href="module-type-HETEROGENEOUS_HASHED_VALUE/index.html">HETEROGENEOUS_HASHED_VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>('k, 'm) <a href="module-type-HETEROGENEOUS_HASHED_VALUE/index.html#type-t">t</a></span> = <span class="type-var">'m</span></span></span></code></div><div class="spec-doc"><p>Generic implementation of <a href="module-type-HETEROGENEOUS_HASHED_VALUE/index.html"><code>HETEROGENEOUS_HASHED_VALUE</code></a>. Uses <a href="https://ocaml.org/api/Hashtbl.html#VALhash"><code>Hashtbl.hash</code></a> for hashing and physical equality for equality. Note that this may lead to maps of different types having the same identifier (<a href="MakeHashconsedHeterogeneousMap/index.html#val-to_int"><code>MakeHashconsedHeterogeneousMap.to_int</code></a>), see the documentation of <a href="module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a> for details on this.</p></div></div><h2 id="functors"><a href="#functors" class="anchor"></a>Functors</h2><p>This section presents the functors which can be used to build patricia tree maps and sets.</p><h3 id="homogeneous-maps-and-sets_2"><a href="#homogeneous-maps-and-sets_2" class="anchor"></a>Homogeneous maps and sets</h3><p>These are homogeneous maps and set, their keys/elements are a single non-generic type, just like the standard library's <code>Map</code> and <code>Set</code> modules.</p><div class="odoc-spec"><div class="spec module anchored" id="module-MakeMap"><a href="#module-MakeMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeMap/index.html">MakeMap</a></span><span> (<a href="MakeMap/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>) : <a href="module-type-MAP/index.html">MAP</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-MAP/index.html#type-key">key</a> = <a href="MakeMap/argument-1-Key/index.html#type-t">Key.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeSet"><a href="#module-MakeSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeSet/index.html">MakeSet</a></span><span> (<a href="MakeSet/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>) : <a href="module-type-SET/index.html">SET</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-SET/index.html#type-elt">elt</a> = <a href="MakeSet/argument-1-Key/index.html#type-t">Key.t</a></span></span></code></div></div><h3 id="heterogeneous-maps-and-sets_2"><a href="#heterogeneous-maps-and-sets_2" class="anchor"></a>Heterogeneous maps and sets</h3><p>Heterogeneous maps are <code>'map map</code>, which store bindings of <code>'key key</code> to <code>('key, 'map) value</code>, where <code>'key key</code> is a GADT, as we must be able to compare keys of different types together.</p><p>Similarly, heterogeneous sets store sets of <code>'key key</code>.</p><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHeterogeneousSet"><a href="#module-MakeHeterogeneousSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHeterogeneousSet/index.html">MakeHeterogeneousSet</a></span><span>
  (<a href="MakeHeterogeneousSet/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>) : 
  <a href="module-type-HETEROGENEOUS_SET/index.html">HETEROGENEOUS_SET</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_SET/index.html#type-elt">elt</a></span> = <span><span class="type-var">'a</span> <a href="MakeHeterogeneousSet/argument-1-Key/index.html#type-t">Key.t</a></span></span></span></code></div><div class="spec-doc"><p>A set containing different keys, very similar to <a href="module-type-SET/index.html"><code>SET</code></a>, but with simple type <code>elt</code> being replaced by type constructor <code>'a elt</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHeterogeneousMap"><a href="#module-MakeHeterogeneousMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHeterogeneousMap/index.html">MakeHeterogeneousMap</a></span><span>
  (<a href="MakeHeterogeneousMap/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  (<a href="MakeHeterogeneousMap/argument-2-Value/index.html">Value</a> : <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a>) : 
  <a href="module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_MAP/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="MakeHeterogeneousMap/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('k, 'm) <a href="module-type-HETEROGENEOUS_MAP/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'m</span>)</span> <a href="MakeHeterogeneousMap/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>This is the same as <a href="module-type-MAP/index.html"><code>MAP</code></a>, but with simple type <code>key</code> being replaced by type constructor <code>'a key</code> and <code>'b value</code> being replaced by <code>('a,'b) value</code>.</p></div></div><h3 id="maps-and-sets-with-custom-nodes"><a href="#maps-and-sets-with-custom-nodes" class="anchor"></a>Maps and sets with custom nodes</h3><p>We can also customize the representation and creation of nodes, to gain space or time.</p><p>Possibitities include having weak key and/or values, hash-consing, giving unique number to nodes or keeping them in sync with the disk, lazy evaluation and/or caching, adding size information for constant time <code>cardinal</code> functions, etc.</p><p>See <a href="#node_impl" title="node_impl">Some implementations of NODE</a> for the provided implementations of <a href="module-type-NODE/index.html"><code>NODE</code></a>, or create your own.</p><div class="odoc-spec"><div class="spec module anchored" id="module-MakeCustomMap"><a href="#module-MakeCustomMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeCustomMap/index.html">MakeCustomMap</a></span><span>
  (<a href="MakeCustomMap/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>)
  (<a href="MakeCustomMap/argument-2-Value/index.html">Value</a> : <a href="module-type-VALUE/index.html">VALUE</a>)
  (<a href="MakeCustomMap/argument-3-Node/index.html">Node</a> : 
    <a href="module-type-NODE/index.html">NODE</a>
      <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <a href="MakeCustomMap/argument-1-Key/index.html#type-t">Key.t</a></span>
       <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span><span class="type-var">'map</span> <a href="MakeCustomMap/argument-2-Value/index.html#type-t">Value.t</a></span>)</span> <a href="#type-snd">snd</a></span></span>) : 
  <a href="module-type-MAP_WITH_VALUE/index.html">MAP_WITH_VALUE</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-MAP_WITH_VALUE/index.html#type-key">key</a> = <a href="MakeCustomMap/argument-1-Key/index.html#type-t">Key.t</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'m <a href="module-type-MAP_WITH_VALUE/index.html#type-value">value</a></span> = <span><span class="type-var">'m</span> <a href="MakeCustomMap/argument-2-Value/index.html#type-t">Value.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'m <a href="module-type-MAP_WITH_VALUE/index.html#type-t">t</a></span> = <span><span class="type-var">'m</span> <a href="MakeCustomMap/argument-3-Node/index.html#type-t">Node.t</a></span></span></span></code></div><div class="spec-doc"><p>Create a homogeneous map with a custom <a href="module-type-NODE/index.html"><code>NODE</code></a>. Also allows customizing the map values</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeCustomSet"><a href="#module-MakeCustomSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeCustomSet/index.html">MakeCustomSet</a></span><span>
  (<a href="MakeCustomSet/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>)
  (<a href="MakeCustomSet/argument-2-Node/index.html">Node</a> : <a href="module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <a href="MakeCustomSet/argument-1-Key/index.html#type-t">Key.t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = unit</span>) : 
  <a href="module-type-SET/index.html">SET</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-SET/index.html#type-elt">elt</a> = <a href="MakeCustomSet/argument-1-Key/index.html#type-t">Key.t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-SET/BaseMap/index.html#type-t">BaseMap.t</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomSet/argument-2-Node/index.html#type-t">Node.t</a></span></span></span></code></div><div class="spec-doc"><p>Create a homogeneous set with a custom <a href="module-type-NODE/index.html"><code>NODE</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeCustomHeterogeneousMap"><a href="#module-MakeCustomHeterogeneousMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeCustomHeterogeneousMap/index.html">MakeCustomHeterogeneousMap</a></span><span>
  (<a href="MakeCustomHeterogeneousMap/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  (<a href="MakeCustomHeterogeneousMap/argument-2-Value/index.html">Value</a> : <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a>)
  (<a href="MakeCustomHeterogeneousMap/argument-3-Node/index.html">Node</a> : 
    <a href="module-type-NODE/index.html">NODE</a>
      <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomHeterogeneousMap/argument-1-Key/index.html#type-t">Key.t</a></span></span>
       <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="MakeCustomHeterogeneousMap/argument-2-Value/index.html#type-t">Value.t</a></span></span>) : 
  <a href="module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_MAP/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomHeterogeneousMap/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('k, 'm) <a href="module-type-HETEROGENEOUS_MAP/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'m</span>)</span> <a href="MakeCustomHeterogeneousMap/argument-2-Value/index.html#type-t">Value.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'m <a href="module-type-HETEROGENEOUS_MAP/index.html#type-t">t</a></span> = <span><span class="type-var">'m</span> <a href="MakeCustomHeterogeneousMap/argument-3-Node/index.html#type-t">Node.t</a></span></span></span></code></div><div class="spec-doc"><p>Create an heterogeneous map with a custom <a href="module-type-NODE/index.html"><code>NODE</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeCustomHeterogeneousSet"><a href="#module-MakeCustomHeterogeneousSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeCustomHeterogeneousSet/index.html">MakeCustomHeterogeneousSet</a></span><span>
  (<a href="MakeCustomHeterogeneousSet/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  (<a href="MakeCustomHeterogeneousSet/argument-2-NODE/index.html">NODE</a> : <a href="module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomHeterogeneousSet/argument-1-Key/index.html#type-t">Key.t</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = unit</span>) : 
  <a href="module-type-HETEROGENEOUS_SET/index.html">HETEROGENEOUS_SET</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_SET/index.html#type-elt">elt</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomHeterogeneousSet/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_SET/BaseMap/index.html#type-t">BaseMap.t</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomHeterogeneousSet/argument-2-NODE/index.html#type-t">NODE.t</a></span></span></span></code></div><div class="spec-doc"><p>Create an heterogeneous set with a custom <a href="module-type-NODE/index.html"><code>NODE</code></a>.</p></div></div><h3 id="hash_consed"><a href="#hash_consed" class="anchor"></a>Hash-consed maps and sets</h3><p>Hash-consed maps and sets uniquely number each of their nodes. Upon creation, they check whether a similar node has been created before, if so they return it, else they return a new node with a new number. With this unique numbering:</p><ul><li><code>equal</code> and <code>compare</code> become constant time operations;</li><li>two maps with the same bindings (where keys compared by <a href="module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a> and values by <a href="module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a>) will always be physically equal;</li><li>functions that benefit from sharing, like <a href="module-type-BASE_MAP/index.html#val-idempotent_union"><code>BASE_MAP.idempotent_union</code></a> and <a href="module-type-BASE_MAP/index.html#val-idempotent_inter"><code>BASE_MAP.idempotent_inter</code></a> will see improved performance;</li><li>constructors are slightly slower, as they now require a hash-table lookup;</li><li>memory usage is increased: nodes store their tags inside themselves, and a global hash-table of all built nodes must be maintained;</li><li>hash-consed maps assume their values are immutable;</li><li><b>WARNING:</b> when using physical equality as <a href="module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a>, some <b>maps of different types may be given the same identifier</b>. See the end of the documentation of <a href="module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a> for details. Note that this is the case in the default implementations <a href="HashedValue/index.html"><code>HashedValue</code></a> and <a href="HeterogeneousHashedValue/index.html"><code>HeterogeneousHashedValue</code></a>.</li></ul><p>All hash-consing functors are <b>generative</b>, since each functor call will create a new hash-table to store the created nodes. Calling a functor twice with same arguments will lead to two numbering systems for identifiers, and thus the types should not be considered compatible.</p><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHashconsedMap"><a href="#module-MakeHashconsedMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHashconsedMap/index.html">MakeHashconsedMap</a></span><span> (<a href="MakeHashconsedMap/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>) (<a href="MakeHashconsedMap/argument-2-Value/index.html">Value</a> : <a href="module-type-HASHED_VALUE/index.html">HASHED_VALUE</a>) () : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Hash-consed version of <a href="module-type-MAP/index.html"><code>MAP</code></a>. See <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a> for the differences between hash-consed and non hash-consed maps.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHashconsedSet"><a href="#module-MakeHashconsedSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHashconsedSet/index.html">MakeHashconsedSet</a></span><span> (<a href="MakeHashconsedSet/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>) () : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Hash-consed version of <a href="module-type-SET/index.html"><code>SET</code></a>. See <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a> for the differences between hash-consed and non hash-consed sets.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHashconsedHeterogeneousSet"><a href="#module-MakeHashconsedHeterogeneousSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHashconsedHeterogeneousSet/index.html">MakeHashconsedHeterogeneousSet</a></span><span>
  (<a href="MakeHashconsedHeterogeneousSet/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  () : 
  <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Hash-consed version of <a href="module-type-HETEROGENEOUS_SET/index.html"><code>HETEROGENEOUS_SET</code></a>. See <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a> for the differences between hash-consed and non hash-consed sets.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHashconsedHeterogeneousMap"><a href="#module-MakeHashconsedHeterogeneousMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHashconsedHeterogeneousMap/index.html">MakeHashconsedHeterogeneousMap</a></span><span>
  (<a href="MakeHashconsedHeterogeneousMap/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  (<a href="MakeHashconsedHeterogeneousMap/argument-2-Value/index.html">Value</a> : <a href="module-type-HETEROGENEOUS_HASHED_VALUE/index.html">HETEROGENEOUS_HASHED_VALUE</a>)
  () : 
  <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Hash-consed version of <a href="module-type-HETEROGENEOUS_MAP/index.html"><code>HETEROGENEOUS_MAP</code></a>. See <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a> for the differences between hash-consed and non hash-consed maps.</p></div></div><h2 id="node_impl"><a href="#node_impl" class="anchor"></a>Some implementations of NODE</h2><p>We provide a few different implementations of <a href="module-type-NODE/index.html"><code>NODE</code></a>, they can be used with the <a href="MakeCustomMap/index.html"><code>MakeCustomMap</code></a>, <a href="MakeCustomSet/index.html"><code>MakeCustomSet</code></a>, <a href="MakeCustomHeterogeneousMap/index.html"><code>MakeCustomHeterogeneousMap</code></a> and <a href="MakeCustomHeterogeneousSet/index.html"><code>MakeCustomHeterogeneousSet</code></a> functors.</p><h3 id="basic-nodes"><a href="#basic-nodes" class="anchor"></a>Basic nodes</h3><div class="odoc-spec"><div class="spec module anchored" id="module-SimpleNode"><a href="#module-SimpleNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="SimpleNode/index.html">SimpleNode</a></span><span>
  (<a href="SimpleNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="SimpleNode/argument-2-Value/index.html">Value</a> : <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a>) : 
  <a href="module-type-NODE/index.html">NODE</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="SimpleNode/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="SimpleNode/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>This module is such that <code>'map t = 'map view</code>. This is the node used in <a href="MakeHeterogeneousMap/index.html"><code>MakeHeterogeneousMap</code></a> and <a href="MakeMap/index.html"><code>MakeMap</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-NodeWithId"><a href="#module-NodeWithId" class="anchor"></a><code><span><span class="keyword">module</span> <a href="NodeWithId/index.html">NodeWithId</a></span><span>
  (<a href="NodeWithId/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="NodeWithId/argument-2-Value/index.html">Value</a> : <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a>) : 
  <a href="module-type-NODE_WITH_ID/index.html">NODE_WITH_ID</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE_WITH_ID/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="NodeWithId/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE_WITH_ID/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="NodeWithId/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>Here, nodes also contain a unique id, e.g. so that they can be used as keys of maps or hash-tables.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-SetNode"><a href="#module-SetNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="SetNode/index.html">SetNode</a></span><span>
  (<a href="SetNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : 
  <a href="module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="SetNode/argument-1-Key/index.html#type-t">Key.t</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = unit</span></span></code></div><div class="spec-doc"><p>An optimized representation for sets, i.e. maps to unit: we do not store a reference to unit (note that you can further optimize when you know the representation of the key). This is the node used in <a href="MakeHeterogeneousSet/index.html"><code>MakeHeterogeneousSet</code></a> and <a href="MakeSet/index.html"><code>MakeSet</code></a>.</p></div></div><h3 id="weak-nodes"><a href="#weak-nodes" class="anchor"></a>Weak nodes</h3><div class="odoc-spec"><div class="spec module anchored" id="module-WeakNode"><a href="#module-WeakNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WeakNode/index.html">WeakNode</a></span><span>
  (<a href="WeakNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="WeakNode/argument-2-Value/index.html">Value</a> : <a href="module-type-HETEROGENEOUS_VALUE/index.html">HETEROGENEOUS_VALUE</a>) : 
  <a href="module-type-NODE/index.html">NODE</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="WeakNode/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="WeakNode/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>NODE used to implement weak key hashes (the key-binding pair is an Ephemeron, the reference to the key is weak, and if the key is garbage collected, the binding disappears from the map</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-WeakSetNode"><a href="#module-WeakSetNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WeakSetNode/index.html">WeakSetNode</a></span><span>
  (<a href="WeakSetNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : 
  <a href="module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="WeakSetNode/argument-1-Key/index.html#type-t">Key.t</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = unit</span></span></code></div><div class="spec-doc"><p>Both a <a href="WeakNode/index.html"><code>WeakNode</code></a> and a <a href="SetNode/index.html"><code>SetNode</code></a>, useful to implement Weak sets.</p></div></div><h3 id="hashconsed-nodes"><a href="#hashconsed-nodes" class="anchor"></a>Hashconsed nodes</h3><div class="odoc-spec"><div class="spec module anchored" id="module-HashconsedNode"><a href="#module-HashconsedNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="HashconsedNode/index.html">HashconsedNode</a></span><span>
  (<a href="HashconsedNode/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  (<a href="HashconsedNode/argument-2-Value/index.html">Value</a> : <a href="module-type-HETEROGENEOUS_HASHED_VALUE/index.html">HETEROGENEOUS_HASHED_VALUE</a>)
  () : 
  <a href="module-type-HASH_CONSED_NODE/index.html">HASH_CONSED_NODE</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HASH_CONSED_NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="HashconsedNode/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-HASH_CONSED_NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="HashconsedNode/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>Gives a unique number to each node like <a href="NodeWithId/index.html"><code>NodeWithId</code></a>, but also performs hash-consing. So two maps with the same bindings will always be physically equal. See <a href="#hash_consed" title="hash_consed">Hash-consed maps and sets</a> for more details on this.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-HashconsedSetNode"><a href="#module-HashconsedSetNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="HashconsedSetNode/index.html">HashconsedSetNode</a></span><span>
  (<a href="HashconsedSetNode/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  () : 
  <a href="module-type-HASH_CONSED_NODE/index.html">HASH_CONSED_NODE</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HASH_CONSED_NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="HashconsedSetNode/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-HASH_CONSED_NODE/index.html#type-value">value</a></span> = unit</span></span></code></div><div class="spec-doc"><p>Both a <a href="HashconsedNode/index.html"><code>HashconsedNode</code></a> and a <a href="SetNode/index.html"><code>SetNode</code></a>.</p></div></div></div></body></html>
