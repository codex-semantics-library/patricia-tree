<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>PatriciaTree (patricia-tree.PatriciaTree)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">patricia-tree</a> &#x00BB; PatriciaTree</nav><header class="odoc-preamble"><h1>Module <code><span>PatriciaTree</span></code></h1><p>Association maps from key to values, and sets, implemented with Patricia Trees, allowing fast merge operations by making use of physical equality between subtrees; and custom implementation of tree nodes (allowing normal maps, hash-consed maps, weak key or value maps, sets, custom maps, etc.)</p><p>This is similar to OCaml's Map, except that:</p><ul><li>The required signature for keys is different, in that we require each key to be mapped to a unique integer identifier.</li></ul><ul><li>The implementation uses Patricia Tree, as described in Oksasaki and Gill's 1998 paper &quot;Fast mergeable integer maps&quot;, i.e. it is a space-efficient prefix trie over the big-endian representation of the key's integer identifier.</li></ul><p>The main benefit of Patricia Tree is that their representation is stable (contrary to maps, inserting nodes in any order will return the same shape), which allows different versions of a map to share more subtrees in memory, and the operations over two maps to benefit from this sharing. The functions in this library attempt to maximally preserve sharing and benefit from sharing, allowing very important improvements in complexity and running time when combining maps or sets is a frequent operation.</p><ul><li>Finally, the implementation is more customizable, allowing notably (key,value) pairs or different types to be in the same map, or to choose the memory representation of the nodes of the tree.</li></ul><ul><li>Some operations like <code>pop_minimum</code> and <code>pop_maximum</code> make our Set suitable as priority queue (but remember that each element in the queue must map to a distinct integer).</li></ul></header><nav class="odoc-toc"><ul><li><a href="#nodes">Nodes</a></li><li><a href="#map-signatures">Map signatures</a><ul><li><a href="#base-map">Base map</a></li><li><a href="#heterogeneous-maps-and-sets">Heterogeneous maps and sets</a></li><li><a href="#homogeneous-maps-and-sets">Homogeneous maps and sets</a></li></ul></li><li><a href="#keys">Keys</a></li><li><a href="#functors">Functors</a><ul><li><a href="#homogeneous-maps-and-sets_2">Homogeneous maps and sets</a></li><li><a href="#heterogeneous-maps-and-sets_2">Heterogeneous maps and sets</a></li><li><a href="#maps-with-custom-representation-of-nodes">Maps with custom representation of Nodes</a></li></ul></li><li><a href="#some-implementations-of-node">Some implementations of NODE</a></li></ul></nav><div class="odoc-content"><p>Note on complexity: in the following, n represents the size of the map when there is one (and <code>|map1|</code> is the number of elements in <code>map1</code>). The term log(n) correspond to the maximum height of the tree, which is log(n) if we assume an even distribution of numbers in the map (e.g. random distribution, or integers chosen contiguously using a counter). The worst-case height is O(max(n,64)) which is actually constant, but not really informative; log(n) corresponds to the real complexity in usual distributions.</p><div class="odoc-spec"><div class="spec type anchored" id="type-intkey"><a href="#type-intkey" class="anchor"></a><code><span><span class="keyword">type</span> intkey</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-mask"><a href="#type-mask" class="anchor"></a><code><span><span class="keyword">type</span> mask</span></code></div></div><h2 id="nodes"><a href="#nodes" class="anchor"></a>Nodes</h2><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-NODE"><a href="#module-type-NODE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-NODE/index.html">NODE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This module explains how a node is stored in memory, with functions to create and view nodes.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-NODE_WITH_ID"><a href="#module-type-NODE_WITH_ID" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-NODE_WITH_ID/index.html">NODE_WITH_ID</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Associate a unique number to each node.</p></div></div><h2 id="map-signatures"><a href="#map-signatures" class="anchor"></a>Map signatures</h2><h3 id="base-map"><a href="#base-map" class="anchor"></a>Base map</h3><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-BASE_MAP"><a href="#module-type-BASE_MAP" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BASE_MAP/index.html">BASE_MAP</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Base map signature: a generic <code>'b map</code> storing bindings of <code>'a key</code> to <code>('a,'b) values</code>. All maps and set are a variation of this type, sometimes with a simplified interface:</p></div></div><h3 id="heterogeneous-maps-and-sets"><a href="#heterogeneous-maps-and-sets" class="anchor"></a>Heterogeneous maps and sets</h3><p>Maps and sets with generic keys <code>'a key</code> and values <code>('a,'b) value</code></p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_MAP"><a href="#module-type-HETEROGENEOUS_MAP" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This is the same as <a href="module-type-MAP/index.html"><code>MAP</code></a>, but with simple type <code>key</code> being replaced by type constructor <code>'a key</code> and <code>'b value</code> being replaced by <code>('a,'b) value</code>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_SET"><a href="#module-type-HETEROGENEOUS_SET" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_SET/index.html">HETEROGENEOUS_SET</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A set containing different keys, very similar to <a href="module-type-SET/index.html"><code>SET</code></a>, but with simple type <code>elt</code> being replaced by type constructor <code>'a elt</code>.</p></div></div><h3 id="homogeneous-maps-and-sets"><a href="#homogeneous-maps-and-sets" class="anchor"></a>Homogeneous maps and sets</h3><p>Same as above, but simple interfaces for non-generic keys</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-SET"><a href="#module-type-SET" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SET/index.html">SET</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Signature for sets implemented using Patricia trees. Most of this interface should be shared with <a href="https://ocaml.org/api/Set.S.html"><code>Stdlib.Set.S</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-snd"><a href="#type-snd" class="anchor"></a><code><span><span class="keyword">type</span> <span>(_, 'b) snd</span></span><span> = </span></code><ol><li id="type-snd.Snd" class="def variant constructor anchored"><a href="#type-snd.Snd" class="anchor"></a><code><span>| </span><span><span class="constructor">Snd</span> <span class="keyword">of</span> <span class="type-var">'b</span></span></code></li></ol></div><div class="spec-doc"><p>The typechecker struggles with forall quantification on values if they don't depend on the first parameter, this wrapping allows our code to pass typechecking by forbidding overly eager simplification.</p><p>This is due to a bug in the typechecker, more info on <a href="https://discuss.ocaml.org/t/weird-behaviors-with-first-order-polymorphism/13783">the OCaml discourse post</a>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-MAP"><a href="#module-type-MAP" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MAP/index.html">MAP</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature for maps with a single type for keys and values. Most of this interface should be shared with <a href="https://ocaml.org/api/Map.S.html"><code>Stdlib.Map.S</code></a>.</p></div></div><h2 id="keys"><a href="#keys" class="anchor"></a>Keys</h2><p>Keys are the functor arguments used to build the maps.</p><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-KEY"><a href="#module-type-KEY" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KEY/index.html">KEY</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature of keys when they are all of the same type.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-cmp"><a href="#type-cmp" class="anchor"></a><code><span><span class="keyword">type</span> <span>(_, _) cmp</span></span><span> = </span></code><ol><li id="type-cmp.Eq" class="def variant constructor anchored"><a href="#type-cmp.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span> : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span> <a href="#type-cmp">cmp</a></span></span></code></li><li id="type-cmp.Diff" class="def variant constructor anchored"><a href="#type-cmp.Diff" class="anchor"></a><code><span>| </span><span><span class="constructor">Diff</span> : <span><span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span> <a href="#type-cmp">cmp</a></span></span></code></li></ol></div><div class="spec-doc"><p>To have heterogeneous keys, we must define a polymorphic equality function. Like in the homogeneous case, it should have the requirement that <code>(to_int a) = (to_int b) ==&gt; polyeq a b = Eq</code>.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-HETEROGENEOUS_KEY"><a href="#module-type-HETEROGENEOUS_KEY" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The signature of heterogeneous keys.</p></div></div><div class="odoc-spec"><div class="spec module-type anchored" id="module-type-VALUE"><a href="#module-type-VALUE" class="anchor"></a><code><span><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-VALUE/index.html">VALUE</a></span><span> = <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The moodule type of values, which can be heterogeneous.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-HomogeneousValue"><a href="#module-HomogeneousValue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="HomogeneousValue/index.html">HomogeneousValue</a></span><span> : <a href="module-type-VALUE/index.html">VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>('a, 'map) <a href="module-type-VALUE/index.html#type-t">t</a></span> = <span class="type-var">'map</span></span></span></code></div><div class="spec-doc"><p>To use when the type of the value is the same (but the keys can still be heterogeneous).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-WrappedHomogeneousValue"><a href="#module-WrappedHomogeneousValue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WrappedHomogeneousValue/index.html">WrappedHomogeneousValue</a></span><span> : <a href="module-type-VALUE/index.html">VALUE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>('a, 'map) <a href="module-type-VALUE/index.html#type-t">t</a></span> = <span><span>(<span class="type-var">'a</span>, <span class="type-var">'map</span>)</span> <a href="#type-snd">snd</a></span></span></span></code></div></div><h2 id="functors"><a href="#functors" class="anchor"></a>Functors</h2><h3 id="homogeneous-maps-and-sets_2"><a href="#homogeneous-maps-and-sets_2" class="anchor"></a>Homogeneous maps and sets</h3><div class="odoc-spec"><div class="spec module anchored" id="module-MakeMap"><a href="#module-MakeMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeMap/index.html">MakeMap</a></span><span> (<a href="MakeMap/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>) : <a href="module-type-MAP/index.html">MAP</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-MAP/index.html#type-key">key</a> = <a href="MakeMap/argument-1-Key/index.html#type-t">Key.t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeSet"><a href="#module-MakeSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeSet/index.html">MakeSet</a></span><span> (<a href="MakeSet/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>) : <a href="module-type-SET/index.html">SET</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-SET/index.html#type-elt">elt</a> = <a href="MakeSet/argument-1-Key/index.html#type-t">Key.t</a></span></span></code></div></div><h3 id="heterogeneous-maps-and-sets_2"><a href="#heterogeneous-maps-and-sets_2" class="anchor"></a>Heterogeneous maps and sets</h3><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHeterogeneousSet"><a href="#module-MakeHeterogeneousSet" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHeterogeneousSet/index.html">MakeHeterogeneousSet</a></span><span>
  (<a href="MakeHeterogeneousSet/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>) : 
  <a href="module-type-HETEROGENEOUS_SET/index.html">HETEROGENEOUS_SET</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_SET/index.html#type-elt">elt</a></span> = <span><span class="type-var">'a</span> <a href="MakeHeterogeneousSet/argument-1-Key/index.html#type-t">Key.t</a></span></span></span></code></div><div class="spec-doc"><p>A set containing different keys, very similar to <a href="module-type-SET/index.html"><code>SET</code></a>, but with simple type <code>elt</code> being replaced by type constructor <code>'a elt</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeHeterogeneousMap"><a href="#module-MakeHeterogeneousMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeHeterogeneousMap/index.html">MakeHeterogeneousMap</a></span><span>
  (<a href="MakeHeterogeneousMap/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  (<a href="MakeHeterogeneousMap/argument-2-Value/index.html">Value</a> : <a href="module-type-VALUE/index.html">VALUE</a>) : 
  <a href="module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_MAP/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="MakeHeterogeneousMap/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('k, 'm) <a href="module-type-HETEROGENEOUS_MAP/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'m</span>)</span> <a href="MakeHeterogeneousMap/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>This is the same as <a href="module-type-MAP/index.html"><code>MAP</code></a>, but with simple type <code>key</code> being replaced by type constructor <code>'a key</code> and <code>'b value</code> being replaced by <code>('a,'b) value</code>.</p></div></div><h3 id="maps-with-custom-representation-of-nodes"><a href="#maps-with-custom-representation-of-nodes" class="anchor"></a>Maps with custom representation of Nodes</h3><p>We can also customize the representation and creation of nodes, to gain space or time.</p><p>Possibitities include having weak key and/or values, hash-consing, giving unique number to nodes or keeping them in sync with the disk, lazy evaluation and/or caching, etc.</p><div class="odoc-spec"><div class="spec module anchored" id="module-MakeCustom"><a href="#module-MakeCustom" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeCustom/index.html">MakeCustom</a></span><span>
  (<a href="MakeCustom/argument-1-Key/index.html">Key</a> : <a href="module-type-KEY/index.html">KEY</a>)
  (<a href="MakeCustom/argument-2-NODE/index.html">NODE</a> : 
    <a href="module-type-NODE/index.html">NODE</a>
      <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <a href="MakeCustom/argument-1-Key/index.html#type-t">Key.t</a></span>
       <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-snd">snd</a></span></span>) : 
  <a href="module-type-MAP/index.html">MAP</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <a href="module-type-MAP/index.html#type-key">key</a> = <a href="MakeCustom/argument-1-Key/index.html#type-t">Key.t</a></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'m <a href="module-type-MAP/index.html#type-t">t</a></span> = <span><span class="type-var">'m</span> <a href="MakeCustom/argument-2-NODE/index.html#type-t">NODE.t</a></span></span></span></code></div><div class="spec-doc"><p>Create a Homogeneous Map with a custom <a href="module-type-NODE/index.html"><code>NODE</code></a>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-MakeCustomHeterogeneous"><a href="#module-MakeCustomHeterogeneous" class="anchor"></a><code><span><span class="keyword">module</span> <a href="MakeCustomHeterogeneous/index.html">MakeCustomHeterogeneous</a></span><span>
  (<a href="MakeCustomHeterogeneous/argument-1-Key/index.html">Key</a> : <a href="module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a>)
  (<a href="MakeCustomHeterogeneous/argument-2-Value/index.html">Value</a> : <a href="module-type-VALUE/index.html">VALUE</a>)
  (<a href="MakeCustomHeterogeneous/argument-3-NODE/index.html">NODE</a> : 
    <a href="module-type-NODE/index.html">NODE</a>
      <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomHeterogeneous/argument-1-Key/index.html#type-t">Key.t</a></span></span>
       <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="MakeCustomHeterogeneous/argument-2-Value/index.html#type-t">Value.t</a></span></span>) : 
  <a href="module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-HETEROGENEOUS_MAP/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="MakeCustomHeterogeneous/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('k, 'm) <a href="module-type-HETEROGENEOUS_MAP/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'k</span>, <span class="type-var">'m</span>)</span> <a href="MakeCustomHeterogeneous/argument-2-Value/index.html#type-t">Value.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>'m <a href="module-type-HETEROGENEOUS_MAP/index.html#type-t">t</a></span> = <span><span class="type-var">'m</span> <a href="MakeCustomHeterogeneous/argument-3-NODE/index.html#type-t">NODE.t</a></span></span></span></code></div><div class="spec-doc"><p>Create an Heterogeneous map with a custom <a href="module-type-NODE/index.html"><code>NODE</code></a>.</p></div></div><h2 id="some-implementations-of-node"><a href="#some-implementations-of-node" class="anchor"></a>Some implementations of NODE</h2><div class="odoc-spec"><div class="spec module anchored" id="module-SimpleNode"><a href="#module-SimpleNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="SimpleNode/index.html">SimpleNode</a></span><span>
  (<a href="SimpleNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="SimpleNode/argument-2-Value/index.html">Value</a> : <a href="module-type-VALUE/index.html">VALUE</a>) : 
  <a href="module-type-NODE/index.html">NODE</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="SimpleNode/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="SimpleNode/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>This module is such that <code>'map t = 'map view</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-NodeWithId"><a href="#module-NodeWithId" class="anchor"></a><code><span><span class="keyword">module</span> <a href="NodeWithId/index.html">NodeWithId</a></span><span>
  (<a href="NodeWithId/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="NodeWithId/argument-2-Value/index.html">Value</a> : <a href="module-type-VALUE/index.html">VALUE</a>) : 
  <a href="module-type-NODE_WITH_ID/index.html">NODE_WITH_ID</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE_WITH_ID/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="NodeWithId/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE_WITH_ID/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="NodeWithId/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>Here, nodes also contain a unique id, e.g. so that they can be used as keys of maps or hashtables.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-SetNode"><a href="#module-SetNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="SetNode/index.html">SetNode</a></span><span>
  (<a href="SetNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : 
  <a href="module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="SetNode/argument-1-Key/index.html#type-t">Key.t</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = unit</span></span></code></div><div class="spec-doc"><p>An optimized representation for sets, i.e. maps to unit: we do not store a reference to unit (note that you can further optimize when you know the representation of the key).</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-WeakNode"><a href="#module-WeakNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WeakNode/index.html">WeakNode</a></span><span>
  (<a href="WeakNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="WeakNode/argument-2-Value/index.html">Value</a> : <a href="module-type-VALUE/index.html">VALUE</a>) : 
  <a href="module-type-NODE/index.html">NODE</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="WeakNode/argument-1-Key/index.html#type-t">Key.t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="WeakNode/argument-2-Value/index.html#type-t">Value.t</a></span></span></span></code></div><div class="spec-doc"><p>NODE used to implement weak key hashes (the key-binding pair is an Ephemeron, the reference to the key is weak, and if the key is garbage collected, the binding disappears from the map</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-WeakSetNode"><a href="#module-WeakSetNode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WeakSetNode/index.html">WeakSetNode</a></span><span>
  (<a href="WeakSetNode/argument-1-Key/index.html">Key</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : 
  <a href="module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="WeakSetNode/argument-1-Key/index.html#type-t">Key.t</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="module-type-NODE/index.html#type-value">value</a></span> = unit</span></span></code></div><div class="spec-doc"><p>Both a <a href="WeakNode/index.html"><code>WeakNode</code></a> and a <a href="SetNode/index.html"><code>SetNode</code></a>, useful to implement Weak sets.</p></div></div></div></body></html>
