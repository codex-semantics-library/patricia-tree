<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Value (patricia-tree.PatriciaTree.MakeHashconsedHeterogeneousMap.Value)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../';
let search_urls = ['../../../db.js','../../../../sherlodoc.js'];
</script><script src="../../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">patricia-tree</a> &#x00BB; <a href="../../index.html">PatriciaTree</a> &#x00BB; <a href="../index.html">MakeHashconsedHeterogeneousMap</a> &#x00BB; Value</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Parameter <code><span>MakeHashconsedHeterogeneousMap.Value</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('key, 'map) t</span></span></code></div><div class="spec-doc"><p>The type of values for a hash-consed maps.</p><p>Unlike <a href="../../module-type-HETEROGENEOUS_VALUE/index.html#type-t"><code>HETEROGENEOUS_VALUE.t</code></a>, <b>hash-consed values should be immutable</b>. Or, if they do mutate, they must not change their <a href="#val-hash"><code>hash</code></a> value, and still be equal to the same values via <a href="#val-polyeq"><code>polyeq</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hash v</code> should return an integer hash for the value <code>v</code>. It is used for <a href="../../index.html#hash_consed" title="hash_consed">hash-consing</a>.</p><p>Hashing should be fast, avoid mapping too many values to the same integer and compatible with <a href="#val-polyeq"><code>polyeq</code></a> (equal values must have the same hash: <code>polyeq v1 v2 = true ==&gt; hash v1 = hash v2</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polyeq"><a href="#val-polyeq" class="anchor"></a><code><span><span class="keyword">val</span> polyeq : <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map_a</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map_b</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Polymorphic equality on values.</p><p><b>WARNING: if <code>polyeq a b</code> is true, then casting <code>b</code> to the type of <code>a</code> (and <code>a</code> to the type of <code>b</code>) must be type-safe.</b> Eg. if <code>a : (k, t1) t</code> and <code>b : (k, t2) t</code> yield <code>polyeq a b = true</code>, then <code>let a' : (k,t2) t = Obj.magic a</code> and <code>let b' : (k,t1) t = Obj.magic b</code> must be safe.</p><p>Examples of safe implementations include:</p><ul><li><p>Having a type <code>('key, 'map) t</code> which doesn't depend on <code>'map</code> (i can depend on <code>'key</code>), in which case casting form <code>('key, 'a) t</code> to <code>('key, 'b) t</code> is always safe:</p><pre class="language-ocaml"><code>type ('k, _) t = 'k list
let cast : type a b. ('k, a) t -&gt; ('k, b) t = fun x -&gt; x
let polyeq : type a b. ('k, a) t -&gt; ('k, b) t -&gt; bool = fun x y -&gt; x = y</code></pre></li><li><p>Using a GADT type and examining its constructors to only return <code>true</code> when the constructors are equal:</p><pre class="language-ocaml"><code>type (_, _) t =
    | T_Int : int -&gt; (unit, int) t
    | T_Bool : bool -&gt; (unit, bool) t
let polyeq : type k a b. (k, a) t -&gt; (k, b) t -&gt; bool = fun x y -&gt;
    match x, y with
    | T_Int i, T_Int j -&gt; i = j (* Here type a = b = int, we can return true *)
    | T_Bool i, T_Bool j -&gt; i &amp;&amp; j (* same here, but with a = b = bool *)
    | _ -&gt; false (* never return true on heterogeneous cases. *)</code></pre></li><li><p>Using physical equality:</p><pre class="language-ocaml"><code>let polyeq a b = a == Obj.magic b</code></pre><p>While this contains an <code>Obj.magic</code>, it is still type safe (OCaml just compares the immediate values) and we can safely cast values from one type to the other if they satisfy this (since they are already physically equal).</p><p>This is the implementation used in <a href="../../HeterogeneousHashedValue/index.html"><code>HeterogeneousHashedValue</code></a>. Note however that using this function can lead to <b>identifiers no longer being unique across types</b>. See <a href="../../module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a> for more information on this.</p></li></ul></div></div></div></body></html>
