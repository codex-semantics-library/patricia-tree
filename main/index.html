<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (patricia-tree.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../';
let search_urls = ['db.js','../sherlodoc.js'];
</script><script src="../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ patricia-tree</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1 id="package-patricia-tree"><a href="#package-patricia-tree" class="anchor"></a>Package patricia-tree</h1><p>This library contains a single module: <a href="PatriciaTree/index.html"><code>PatriciaTree</code></a>.</p><p>This is version <code>0.10.0</code> of the library. It is known to work with OCaml versions ranging from <code>4.14</code> to <code>5.2</code>.</p><p>This is an <a href="https://ocaml.org/">OCaml</a> library that implements sets and maps as Patricia Trees, as described in Okasaki and Gill's 1998 paper <a href="https://www.semanticscholar.org/paper/Fast-Mergeable-Integer-Maps-Okasaki-Gill/23003be706e5f586f23dd7fa5b2a410cc91b659d"><i>Fast mergeable integer maps</i></a>. It is a space-efficient prefix trie over the big-endian representation of the key's integer identifier.</p><p>The source code of this library is available <a href="https://github.com/codex-semantics-library/patricia-tree">on Github</a> under an <a href="https://choosealicense.com/licenses/lgpl-2.1/">LGPL-2.1</a> license.</p><p>This library was written by <a href="https://www.researchgate.net/profile/Matthieu-Lemerre">Matthieu Lemerre</a>, then further improved by <a href="https://www.normalesup.org/~dlesbre/">Dorian Lesbre</a>, as part of the <a href="https://codex.top/">Codex semantics library</a>, developed at <a href="https://list.cea.fr/en/">CEA List</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#installation">Installation</a></li><li><a href="#features">Features</a></li><li><a href="#quick-overview">Quick overview</a><ul><li><a href="#functors">Functors</a></li><li><a href="#interfaces">Interfaces</a></li></ul></li><li><a href="#examples">Examples</a><ul><li><a href="#homogeneous-map">Homogeneous map</a></li><li><a href="#heterogeneous-map">Heterogeneous map</a></li></ul></li><li><a href="#release-status">Release status</a></li><li><a href="#known-issues">Known issues</a></li><li><a href="#comparison-to-other-ocaml-libraries">Comparison to other OCaml libraries</a><ul><li><a href="#ptmap-and-ptset">ptmap and ptset</a></li><li><a href="#dmap">dmap</a></li></ul></li><li><a href="#contributions-and-bug-reports">Contributions and bug reports</a></li></ul></nav><div class="odoc-content"><h2 id="installation"><a href="#installation" class="anchor"></a>Installation</h2><p>This library can be installed with <a href="https://opam.ocaml.org/">opam</a>:</p><pre class="language-bash"><code>opam install patricia-tree</code></pre><p>Alternatively, you can clone the source repository and install with <a href="https://dune.build/">dune</a>:</p><pre class="language-bash"><code>git clone git@github.com:codex-semantics-library/patricia-tree.git
cd patricia-tree
opan install . --deps-only
dune build -p patricia-tree
dune install
# To build documentation
opam install . --deps-only --with-doc
dune build @doc</code></pre><h2 id="features"><a href="#features" class="anchor"></a>Features</h2><ul><li>Similar to OCaml's <a href="https://ocaml.org/api/Map.S.html"><code>Map</code></a> and <a href="https://ocaml.org/api/Set.S.html"><code>Set</code></a>, using the same function names when possible and the same convention for order of arguments. This should allow switching to and from Patricia Tree with minimal effort.</li><li>The functor parameters (<a href="PatriciaTree/module-type-KEY/index.html" title="PatriciaTree.KEY"><code>KEY</code></a> module) requires an injective <code>to_int : t -&gt; int</code> function instead of a <code>compare</code> function. <a href="PatriciaTree/module-type-KEY/index.html#val-to_int" title="PatriciaTree.KEY.to_int"><code>KEY.to_int</code></a> should be fast, and injective. This works well with <a href="https://en.wikipedia.org/wiki/Hash_consing">hash-consed</a> types.</li><li><p>The Patricia Tree representation is stable, contrary to maps, inserting nodes in any order will return the same shape. This allows different versions of a map to share more subtrees in memory, and the operations over two maps to benefit from this sharing. The functions in this library attempt to <b>maximally preserve sharing and benefit from sharing</b>, allowing very important improvements in complexity and running time when combining maps or sets is a frequent operation.</p><p>To do so, these functions often have extra requirements on their argument (e.g. <code>inter f m1 m2</code> can be optimized by not inspecting common subtrees when <code>f</code> is idempotent). To avoid accidental errors, they are renamed (e.g. to <code>idempotent_inter</code> for the efficient version and <code>nonidempotent_inter_no_share</code> for the general one)</p></li><li><p>Since our Patricia Tree use big-endian order on keys, the maps and sets are sorted in increasing <b><a href="PatriciaTree/index.html#val-unsigned_lt" title="PatriciaTree.unsigned_lt">unsigned order</a></b> of keys. This means negative keys are sorted above positive keys, with <code>-1</code> being the largest possible key, and <code>0</code> the smallest. This also avoids a bug in Okasaki's paper discussed in <a href="https://www.cs.tufts.edu/comp/150FP/archive/jan-midtgaard/qc-patricia.pdf"><i>QuickChecking Patricia Trees</i></a> by Jan Mitgaard.</p><p>It also affects functions like <a href="PatriciaTree/module-type-BASE_MAP/index.html#val-unsigned_min_binding" title="PatriciaTree.BASE_MAP.unsigned_min_binding"><code>unsigned_min_binding</code></a> and <a href="PatriciaTree/module-type-BASE_MAP/index.html#val-pop_unsigned_minimum" title="PatriciaTree.BASE_MAP.pop_unsigned_minimum"><code>pop_unsigned_minimum</code></a>. They will return the smallest positive integer of both positive and negative keys are present; and not the smallest negative, as one might expect.</p></li><li>Supports generic maps and sets: a <code>'m map</code> that maps <code>'k key</code> to <code>('k, 'm) value</code>. This is especially useful when using <a href="https://v2.ocaml.org/manual/gadts-tutorial.html">GADTs</a> for the type of keys. This is also sometimes called a dependent map.</li><li>Allows easy and fast operations across different types of maps and set which have the same type of keys (e.g. an intersection between a map and a set).</li><li>Multiple choices for internal representation (<a href="PatriciaTree/module-type-NODE/index.html" title="PatriciaTree.NODE"><code>NODE</code></a>), which allows for efficient storage (no need to store a value for sets), or using weak nodes only (values removed from the tree if no other pointer to it exists). This system can also be extended to store size information in nodes if needed.</li><li>Exposes a common interface (<a href="PatriciaTree/module-type-NODE/index.html#type-view"><code>PatriciaTree.NODE.view</code></a>) to allow users to write their own pattern matching on the tree structure without depending on the <a href="PatriciaTree/module-type-NODE/index.html" title="PatriciaTree.NODE"><code>NODE</code></a> being used.</li><li>Additionally, hashconsed versions of heterogeneous/homogeneous maps/sets are available. These provide constant time equality and comparison, and ensure maps/set with the same constants are always physically equal. It comes at the cost of a constant overhead in memory usage (at worst, as hash-consing may allow memory gains) and constant time overhead when calling constructors.</li></ul><h2 id="quick-overview"><a href="#quick-overview" class="anchor"></a>Quick overview</h2><h3 id="functors"><a href="#functors" class="anchor"></a>Functors</h3><p>This library contains a single module, <a href="PatriciaTree/index.html"><code>PatriciaTree</code></a>. The functors used to build maps and sets are the following:</p><ul><li><p>For homogeneous (non-generic) maps and sets: <a href="PatriciaTree/MakeMap/index.html" title="PatriciaTree.MakeMap"><code>MakeMap</code></a> and <a href="PatriciaTree/MakeSet/index.html" title="PatriciaTree.MakeSet"><code>MakeSet</code></a>. These are similar to the standard library's maps and sets.</p><pre class="language-ocaml"><code>module MakeMap(Key: KEY) : MAP with type key = Key.t
module MakeSet(Key: KEY) : SET with type elt = Key.t</code></pre></li><li><p>For Heterogeneous (generic) maps and sets: <a href="PatriciaTree/MakeHeterogeneousMap/index.html" title="PatriciaTree.MakeHeterogeneousMap"><code>MakeHeterogeneousMap</code></a> and <a href="PatriciaTree/MakeHeterogeneousSet/index.html" title="PatriciaTree.MakeHeterogeneousSet"><code>MakeHeterogeneousSet</code></a>.</p><pre class="language-ocaml"><code>module MakeHeterogeneousMap(Key: HETEROGENEOUS_KEY)(Value: HETEROGENEOUS_VALUE) :
  HETEROGENEOUS_MAP
  with type 'a key = 'a Key.t
   and type ('k,'m) value = ('k,'m) Value.t
module MakeHeterogeneousSet(Key: HETEROGENEOUS_KEY) : HETEROGENEOUS_SET
  with type 'a elt = 'a Key.t</code></pre></li><li><p>There are also <a href="https://en.wikipedia.org/wiki/Hash_consing">hash-consed</a> versions of these four functors: <a href="PatriciaTree/MakeHashconsedMap/index.html" title="PatriciaTree.MakeHashconsedMap"><code>MakeHashconsedMap</code></a>, <a href="PatriciaTree/MakeHashconsedSet/index.html" title="PatriciaTree.MakeHashconsedSet"><code>MakeHashconsedSet</code></a>, <a href="PatriciaTree/MakeHashconsedHeterogeneousMap/index.html" title="PatriciaTree.MakeHashconsedHeterogeneousMap"><code>MakeHashconsedHeterogeneousMap</code></a> and <a href="PatriciaTree/MakeHashconsedHeterogeneousSet/index.html" title="PatriciaTree.MakeHashconsedHeterogeneousSet"><code>MakeHashconsedHeterogeneousSet</code></a>. These uniquely number their nodes, which means:</p><ul><li><code>equal</code> and <code>compare</code> become constant time operations;</li><li>two maps with the same bindings (where keys are compared by <a href="PatriciaTree/module-type-KEY/index.html#val-to_int" title="PatriciaTree.KEY.to_int"><code>KEY.to_int</code></a> and values by <a href="PatriciaTree/module-type-HASHED_VALUE/index.html#val-polyeq" title="PatriciaTree.HASHED_VALUE.polyeq"><code>HASHED_VALUE.polyeq</code></a>) will always be physically equal;</li><li>functions that benefit from sharing will see improved performance;</li><li>constructors are slightly slower, as they now require a hash-table lookup;</li><li>memory usage is increased: nodes store their tags inside themselves, and a global hash-table of all built nodes must be maintained;</li><li>hash-consed maps assume their values are immutable;</li><li><b>WARNING:</b> when using physical equality as <a href="PatriciaTree/module-type-HASHED_VALUE/index.html#val-polyeq" title="PatriciaTree.HASHED_VALUE.polyeq"><code>HASHED_VALUE.polyeq</code></a>, some maps of different types may be given the same identifier. See the end of the documentation of <a href="PatriciaTree/module-type-HASHED_VALUE/index.html#val-polyeq" title="PatriciaTree.HASHED_VALUE.polyeq"><code>HASHED_VALUE.polyeq</code></a> for details. Note that this is the case in the default implementations <a href="PatriciaTree/HashedValue/index.html" title="PatriciaTree.HashedValue"><code>HashedValue</code></a> and <a href="PatriciaTree/HeterogeneousHashedValue/index.html" title="PatriciaTree.HeterogeneousHashedValue"><code>HeterogeneousHashedValue</code></a>.</li><li>All hash-consing functors are <b>generative</b>, since each functor call will create a new hash-table to store the created nodes. Calling a functor twice with same arguments will lead to two numbering systems for identifiers, and thus the types should not be considered compatible.</li></ul></li></ul><h3 id="interfaces"><a href="#interfaces" class="anchor"></a>Interfaces</h3><p>Here is a brief overview of the various module types of our library:</p><ul><li><p><a href="PatriciaTree/module-type-BASE_MAP/index.html" title="PatriciaTree.BASE_MAP"><code>BASE_MAP</code></a>: the underlying module type of all our trees (maps end sets). It represents a <code>'b map</code> binding <code>'a key</code> to <code>('a,'b) value</code>, as well as all functions needed to manipulate them.</p><p>It can be accessed from any of the more specific maps types, thus providing a unified representation, useful for cross map operations. However, for practical purposes, it is often best to use the more specific interfaces:</p><ul><li><a href="PatriciaTree/module-type-HETEROGENEOUS_MAP/index.html" title="PatriciaTree.HETEROGENEOUS_MAP"><code>HETEROGENEOUS_MAP</code></a> for heterogeneous maps (this is just <a href="PatriciaTree/module-type-BASE_MAP/index.html" title="PatriciaTree.BASE_MAP"><code>BASE_MAP</code></a> with a <code>WithForeign</code> functor).</li><li><a href="PatriciaTree/module-type-MAP/index.html" title="PatriciaTree.MAP"><code>MAP</code></a> for homogeneous maps, this interface is close to <a href="https://ocaml.org/api/Map.S.html"><code>Stdlib.Map.S</code></a>.</li><li><a href="PatriciaTree/module-type-HETEROGENEOUS_SET/index.html" title="PatriciaTree.HETEROGENEOUS_SET"><code>HETEROGENEOUS_SET</code></a> for heterogeneous sets (sets of <code>'a elt</code>). These are just maps to <code>unit</code>, but with a custom node representation to avoid storing <code>unit</code> in nodes.</li><li><a href="PatriciaTree/module-type-SET/index.html" title="PatriciaTree.SET"><code>SET</code></a> for homogeneous sets, this interface is close to <a href="https://ocaml.org/api/Set.S.html"><code>Stdlib.Set.S</code></a>.</li></ul></li><li><p>The parameter of our functor are either <a href="PatriciaTree/module-type-KEY/index.html" title="PatriciaTree.KEY"><code>KEY</code></a> or <a href="PatriciaTree/module-type-HETEROGENEOUS_KEY/index.html" title="PatriciaTree.HETEROGENEOUS_KEY"><code>HETEROGENEOUS_KEY</code></a>. These just consist of a type, a (polymorphic) equality function, and an injective <code>to_int</code> coercion.</p><p>The heterogeneous map functor also has a <a href="PatriciaTree/module-type-HETEROGENEOUS_VALUE/index.html" title="PatriciaTree.HETEROGENEOUS_VALUE"><code>HETEROGENEOUS_VALUE</code></a> parameter to specify the <code>('a, 'b) value</code> type.</p></li><li><p>The internal representations of our tree can be customized to use different internal <a href="PatriciaTree/module-type-NODE/index.html" title="PatriciaTree.NODE"><code>NODE</code></a>. Each node come with its own private constructors and destructors, as well as a cast to a uniform <a href="PatriciaTree/module-type-NODE/index.html#type-view" title="PatriciaTree.NODE.view"><code>NODE.view</code></a> type used for pattern matching.</p><p>A number of implementations are provided:</p><ul><li><a href="PatriciaTree/SimpleNode/index.html" title="PatriciaTree.SimpleNode"><code>SimpleNode</code></a>: exactly the <a href="PatriciaTree/module-type-NODE/index.html#type-view" title="PatriciaTree.NODE.view"><code>NODE.view</code></a> type;</li><li><a href="PatriciaTree/WeakNode/index.html" title="PatriciaTree.WeakNode"><code>WeakNode</code></a>: only store weak pointer to its elements;</li><li><a href="PatriciaTree/NodeWithId/index.html" title="PatriciaTree.NodeWithId"><code>NodeWithId</code></a>: node which contains a unique identifier;</li><li><a href="PatriciaTree/SetNode/index.html" title="PatriciaTree.SetNode"><code>SetNode</code></a>: optimized for sets, doesn't store the <code>unit</code> value;</li><li><a href="PatriciaTree/WeakSetNode/index.html" title="PatriciaTree.WeakSetNode"><code>WeakSetNode</code></a>: both a <a href="PatriciaTree/WeakNode/index.html" title="PatriciaTree.WeakNode"><code>WeakNode</code></a> and a <a href="PatriciaTree/SetNode/index.html" title="PatriciaTree.SetNode"><code>SetNode</code></a></li><li><a href="PatriciaTree/HashconsedNode/index.html" title="PatriciaTree.HashconsedNode"><code>HashconsedNode</code></a>: performs hash-consing (it also stores a unique identifier, but checks when building a new node whether a node with similar content already exists);</li><li><a href="PatriciaTree/HashconsedSetNode/index.html" title="PatriciaTree.HashconsedSetNode"><code>HashconsedSetNode</code></a>: both a <a href="PatriciaTree/HashconsedNode/index.html" title="PatriciaTree.HashconsedNode"><code>HashconsedNode</code></a> and a <a href="PatriciaTree/SetNode/index.html" title="PatriciaTree.SetNode"><code>SetNode</code></a>.</li></ul><p>Use the functors <a href="PatriciaTree/MakeCustomMap/index.html" title="PatriciaTree.MakeCustomMap"><code>MakeCustomMap</code></a> and <a href="PatriciaTree/MakeCustomSet/index.html" title="PatriciaTree.MakeCustomSet"><code>MakeCustomSet</code></a> (or their heterogeneous versions <a href="PatriciaTree/MakeCustomHeterogeneousMap/index.html" title="PatriciaTree.MakeCustomHeterogeneousMap"><code>MakeCustomHeterogeneousMap</code></a> and <a href="PatriciaTree/MakeCustomHeterogeneousSet/index.html" title="PatriciaTree.MakeCustomHeterogeneousSet"><code>MakeCustomHeterogeneousSet</code></a>) to build maps using these nodes, or any other custom nodes.</p></li></ul><h2 id="examples"><a href="#examples" class="anchor"></a>Examples</h2><h3 id="homogeneous-map"><a href="#homogeneous-map" class="anchor"></a>Homogeneous map</h3><p>Here is a small example of a non-generic map:</p><ol><li><p>Start by creating a key module:</p><pre class="language-ocaml"><code>module IntKey : PatriciaTree.KEY with type t = int = struct
  type t = int
  let to_int x = x
end</code></pre></li><li><p>Use it to instanciate the map/set functors:</p><pre class="language-ocaml"><code>module IMap : PatriciaTree.MAP with type key = int = PatriciaTree.MakeMap(IntKey);;
module ISet : PatriciaTree.SET with type elt = int = PatriciaTree.MakeSet(IntKey);;</code></pre></li><li><p>You can now use it as you would any other map:</p><pre class="language-ocaml"><code># let map =
  IMap.empty |&gt;
  IMap.add 1 &quot;hello&quot; |&gt;
  IMap.add 2 &quot;world&quot; |&gt;
  IMap.add 3 &quot;how do you do?&quot;;;
val map : string IMap.t = &lt;abstr&gt;</code></pre><p>(We also have <a href="PatriciaTree/module-type-MAP/index.html#val-of_list" title="PatriciaTree.MAP.of_list"><code>of_list</code></a> and <a href="PatriciaTree/module-type-MAP/index.html#val-of_seq" title="PatriciaTree.MAP.of_seq"><code>of_seq</code></a> functions for quick initialization)</p><pre class="language-ocaml"><code># IMap.find 1 map;;
- : string = &quot;hello&quot;
# IMap.cardinal map;;
- : int = 3</code></pre></li><li><p>The strength of Patricia Tree is the speedup of operations on multiple maps with common subtrees. For example, in the following, the <a href="PatriciaTree/module-type-MAP/index.html#val-idempotent_inter_filter" title="PatriciaTree.MAP.idempotent_inter_filter"><code>idempotent_inter_filter</code></a> function will skip recursive calls to physically equal subtrees (kept as-is in the intersection). This allows faster than <code>O(n)</code> intersections.</p><pre class="language-ocaml"><code># let map2 =
    IMap.idempotent_inter_filter (fun _key _l _r -&gt; None)
      (IMap.add 4 &quot;something&quot; map)
      (IMap.add 5 &quot;something else&quot; map);;
val map2 : string IMap.t = &lt;abstr&gt;
# map == map2;;
- : bool = true</code></pre><p>Physical equality is preserved as much as possible, although some intersections may need to build new nodes and won't be fully physically equal, they will still share some subtrees.</p><pre class="language-ocaml"><code># let str = IMap.find 1 map;;
val str : string = &quot;hello&quot;
# IMap.add 1 str map == map (* already present *);;
- : bool = true
# IMap.add 1 &quot;hello&quot; map == map
  (* new string copy isn't physically equal to the old one *);;
- : bool = false</code></pre><p>Note that physical equality isn't preserved when creating new copies of values (the newly created string <code>&quot;hello&quot;</code> isn't physically equal to <code>str</code>). It can also fail when maps have the same bindings but were created differently:</p><pre class="language-ocaml"><code># let map3 = IMap.remove 2 map;;
val map3 : string IMap.t = &lt;abstr&gt;
# IMap.add 2 (IMap.find 2 map) map3 == map;;
- : bool = false</code></pre><p>If you want to maintain full physical equality (and thus get cheap equality test between maps), use the provided <a href="PatriciaTree/index.html#hash_consed" title="hash_consed">hash-consed maps and sets</a>.</p></li><li><p>Our library also allows cross map/set operations through the <a href="PatriciaTree/module-type-MAP/WithForeign/index.html" title="PatriciaTree.MAP.WithForeign"><code>WithForeign</code></a> functors:</p><pre class="language-ocaml"><code>module CrossOperations = IMap.WithForeign(ISet.BaseMap)</code></pre><p>For example, you can only keep the bindings of <code>map</code> whose keys are in a given set:</p><pre class="language-ocaml"><code># let set = ISet.of_list [1; 3];;
val set : ISet.t = &lt;abstr&gt;
# let restricted_map = CrossOperations.nonidempotent_inter
  { f = fun _key value () -&gt; value } map set;;
val restricted_map : string IMap.t = &lt;abstr&gt;
# IMap.to_list map;;
- : (int * string) list = [(1, &quot;hello&quot;); (2, &quot;world&quot;); (3, &quot;how do you do?&quot;)]
# IMap.to_list restricted_map;;
- : (int * string) list = [(1, &quot;hello&quot;); (3, &quot;how do you do?&quot;)]</code></pre></li></ol><h3 id="heterogeneous-map"><a href="#heterogeneous-map" class="anchor"></a>Heterogeneous map</h3><p>Heterogeneous maps work very similarly to homogeneous ones, but come with extra liberty of having a generic type as a key.</p><ol><li><p>Here is a GADT example to use for our keys: a small typed expression language.</p><pre class="language-ocaml"><code>type 'a expr =
  | G_Const_Int : int -&gt; int expr
  | G_Const_Bool : bool -&gt; bool expr
  | G_Addition : int expr * int expr -&gt; int expr
  | G_Equal : 'a expr * 'a expr -&gt; bool expr</code></pre><p>We can create our <a href="PatriciaTree/module-type-HETEROGENEOUS_KEY/index.html" title="PatriciaTree.HETEROGENEOUS_KEY"><code>HETEROGENEOUS_KEY</code></a> functor parameter using this type has follows:</p><pre class="language-ocaml"><code>module Expr : PatriciaTree.HETEROGENEOUS_KEY with type 'a t = 'a expr = struct
  type 'a t = 'a expr

  (** Injective, so long as expressions are small enough
      (encodes the constructor discriminant in two lowest bits).
      Ideally, use a hash-consed type, to_int needs to be fast *)
  let rec to_int : type a. a expr -&gt; int = function
    | G_Const_Int i -&gt;   0 + 4*i
    | G_Const_Bool b -&gt;  1 + 4*(if b then 1 else 0)
    | G_Addition(l,r) -&gt; 2 + 4*(to_int l mod 10000 + 10000*(to_int r))
    | G_Equal(l,r) -&gt;    3 + 4*(to_int l mod 10000 + 10000*(to_int r))

  (** Full polymorphic equality *)
  let rec polyeq : type a b. a expr -&gt; b expr -&gt; (a, b) PatriciaTree.cmp =
    fun l r -&gt; match l, r with
    | G_Const_Int l, G_Const_Int r -&gt; if l = r then Eq else Diff
    | G_Const_Bool l, G_Const_Bool r -&gt; if l = r then Eq else Diff
    | G_Addition(ll, lr), G_Addition(rl, rr) -&gt; (
        match polyeq ll rl with
        | Eq -&gt; polyeq lr rr
        | Diff -&gt; Diff)
    | G_Equal(ll, lr), G_Equal(rl, rr) -&gt;    (
        match polyeq ll rl with
        | Eq -&gt; (match polyeq lr rr with Eq -&gt; Eq | Diff -&gt; Diff) (* Match required by typechecker *)
        | Diff -&gt; Diff)
    | _ -&gt; Diff
end</code></pre></li><li><p>We can now instanciate our map functor. Note that in the heterogeneous case, we must also specify the value type (second functor argument) and how it depends on the key type (first parameter) and the map type (second parameter). Here the value only depends on the type of the key, not that of the map</p><pre class="language-ocaml"><code>module EMap = PatriciaTree.MakeHeterogeneousMap(Expr)(struct type ('a, _) t = 'a end)</code></pre></li><li><p>You can now use this as you would any other dependent map:</p><pre class="language-ocaml"><code># let map : unit EMap.t =
  EMap.empty |&gt;
  EMap.add (G_Const_Bool false) false |&gt;
  EMap.add (G_Const_Int 5) 5 |&gt;
  EMap.add (G_Addition (G_Const_Int 3, G_Const_Int 6)) 9 |&gt;
  EMap.add (G_Equal (G_Const_Bool false, G_Equal (G_Const_Int 5, G_Const_Int 7))) true
val map : unit EMap.t = &lt;abstr&gt;
# EMap.find (G_Const_Bool false) map;;
- : bool = false
# EMap.find (G_Const_Int 5) map;;
- : int = 5
# EMap.cardinal map;;
- : int = 4</code></pre></li><li><p>Physical equality preservation allows fast operations on multiple maps with common ancestors. In the heterogeneous case, these functions are a bit more complex since OCaml requires that first-order polymorphic functions be wrapped in records:</p><pre class="language-ocaml"><code># let map2 = EMap.idempotent_inter_filter
    { f = fun _key _l _r -&gt; None } (* polymorphic 1rst order functions are wrapped in records *)
    (EMap.add (G_Const_Int 0) 8 map)
    (EMap.add (G_Const_Int 0) 9 map)
val map2 : unit EMap.t = &lt;abstr&gt;</code></pre><p>Even though <code>map</code> and <code>map2</code> have the same elements, they may not always be physically equal:</p><pre class="language-ocaml"><code># map == map2;;
- : bool = false</code></pre><p>This is because they were created through different processes. They will still share subtrees. If you want to maintain full physical equality (and thus get cheap equality test between maps), use the provided <a href="PatriciaTree/index.html#hash_consed" title="hash_consed">hash-consed maps and sets</a>.</p></li></ol><h2 id="release-status"><a href="#release-status" class="anchor"></a>Release status</h2><p>This should be close to a stable release. It is already being used as part of a larger project successfully, and this usage as helped us mature the interface. As is, we believe the project is usable, and we don't anticipate any major change before 1.0.0. We didn't commit to a stable release straight away as we would like a bit more time using this library before doing so.</p><h2 id="known-issues"><a href="#known-issues" class="anchor"></a>Known issues</h2><p>There is a bug in the OCaml typechecker which prevents us from directly defining non-generic maps as instances of generic maps. To avoid this, non-generic maps use a separate value type <a href="PatriciaTree/index.html#type-snd" title="PatriciaTree.snd"><code>('a, 'b) snd</code></a> (instead of just using <code>'b</code>)</p><pre class="language-ocaml"><code>type (_, 'b) snd = Snd of 'b [@@unboxed]</code></pre><p>It should not incur any extra performance cost as it is unboxed, but can appear when manipulating non-generic maps.</p><p>For more details about this issue, see <a href="https://discuss.ocaml.org/t/weird-behaviors-with-first-order-polymorphism/13783">the OCaml discourse discussion</a>.</p><h2 id="comparison-to-other-ocaml-libraries"><a href="#comparison-to-other-ocaml-libraries" class="anchor"></a>Comparison to other OCaml libraries</h2><h3 id="ptmap-and-ptset"><a href="#ptmap-and-ptset" class="anchor"></a>ptmap and ptset</h3><p>There are other implementations of Patricia Tree in OCaml, namely <a href="https://github.com/backtracking/ptmap">ptmap</a> and <a href="https://github.com/backtracking/ptset">ptset</a>, both by J.C. Filliatre. These are smaller and closer to OCaml's built-in <code>Map</code> and <code>Set</code>, however:</p><ul><li>Our library allows using any type <code>key</code> that comes with an injective <code>to_int</code> function, instead of requiring <code>key = int</code>.</li><li>We support generic types for keys/elements.</li><li>We support operations between sets and maps of different types.</li><li>We use a big-endian representation, allowing easy access to min/max elements of maps and trees.</li><li>Our interface and implementation tries to maximize the sharing between different versions of the tree, and to benefit from this memory sharing. Theirs do not.</li><li>These libraries work with older version of OCaml (<code>&gt;= 4.05</code> I believe), whereas ours requires OCaml <code>&gt;= 4.14</code> (for the new interface of <a href="https://v2.ocaml.org/api/Ephemeron.html"><code>Ephemeron</code></a> used in <a href="PatriciaTree/WeakNode/index.html" title="PatriciaTree.WeakNode"><code>WeakNode</code></a>).</li></ul><h3 id="dmap"><a href="#dmap" class="anchor"></a>dmap</h3><p>Additionally, there is a dependent map library: <a href="https://gitlab.inria.fr/bmontagu/dmap">dmap</a>, which gave us the idea of making our PatriciaTree dependent. It allows creating type safe dependent maps similar to our heterogeneous maps. However, its maps aren't Patricia trees. They are binary trees build using a (polymorphic) comparison function, similarly to the maps of the standard library.</p><p>Another difference is that the type of values in the map is independent from the type of the keys, allowing keys to be associated with different values in different maps. i.e. we map <code>'a key</code> to any <code>('a, 'b) value</code> type, whereas dmap only maps <code>'a key</code> to <code>'a</code> or <code>'a value</code>.</p><p><code>dmap</code> also works with OCaml <code>&gt;= 4.12</code>, whereas we require OCaml <code>&gt;= 4.14</code>.</p><h2 id="contributions-and-bug-reports"><a href="#contributions-and-bug-reports" class="anchor"></a>Contributions and bug reports</h2><p>Any contributions are welcome!</p><p>You can report any bug, issues, or desired features using the <a href="https://github.com/codex-semantics-library/patricia-tree/issues">Github issue tracker</a>. Please include OCaml, dune, and library version information in you bug reports.</p><p>If you want to contribute code, feel free to fork <a href="https://github.com/codex-semantics-library/patricia-tree">the repository on Github</a> and open a pull request. By doing so you agree to release your code under this project's license (<a href="https://choosealicense.com/licenses/lgpl-2.1/">LGPL-2.1</a>).</p><p>There is no imposed coding style for this repository, here are just a few guidelines and conventions:</p><ul><li>Module type names should use <code>SCREAMING_SNAKE_CASE</code>.</li><li>Module and functor names use <code>PascalCase</code>, functors names start with <code>Make</code>.</li><li>Even though the library implements homogeneous maps as a specialization of heterogeneous ones, the naming convention is that no prefix means homogeneous, and all heterogeneous objects are prefixed with <code>heterogeneous</code>.</li><li>Please document any new functions in the interface, using <a href="https://v2.ocaml.org/manual/ocamldoc.html#s%3Aocamldoc-comments">ocamldoc style comments</a>.</li><li>Please consider adding test for new features/fixed bugs if at all possible. This library uses a <a href="https://www.ocaml.org/p/quickcheck/latest/doc/QuickCheck/index.html">QuickCheck</a> framework for tests.</li></ul></div></body></html>
