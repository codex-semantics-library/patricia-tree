<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Value (patricia-tree.PatriciaTree.MakeHashconsedMap.Value)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../../';
let search_urls = ['../../../db.js','../../../../sherlodoc.js'];
</script><script src="../../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">patricia-tree</a> &#x00BB; <a href="../../index.html">PatriciaTree</a> &#x00BB; <a href="../index.html">MakeHashconsedMap</a> &#x00BB; Value</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Parameter <code><span>MakeHashconsedMap.Value</span></code></h1></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>The type of values for a hash-consed maps.</p><p>Unlike <a href="../../module-type-VALUE/index.html#type-t"><code>VALUE.t</code></a>, <b>hash-consed values should be immutable</b>. Or, if they do mutate, they must not change their <a href="#val-hash"><code>hash</code></a> value, and still be equal to the same values via <a href="#val-polyeq"><code>polyeq</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>hash v</code> should return an integer hash for the value <code>v</code>. It is used for <a href="../../index.html#hash_consed" title="hash_consed">hash-consing</a>.</p><p>Hashing should be fast, avoid mapping too many values to the same integer and compatible with <a href="#val-polyeq"><code>polyeq</code></a> (equal values must have the same hash: <code>polyeq v1 v2 = true ==&gt; hash v1 = hash v2</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-polyeq"><a href="#val-polyeq" class="anchor"></a><code><span><span class="keyword">val</span> polyeq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Polymorphic equality on values.</p><p><b>WARNING: if <code>polyeq a b</code> is true, then casting <code>b</code> to the type of <code>a</code> (and <code>a</code> to the type of <code>b</code>) must be type-safe.</b> Eg. if <code>a : t1 t</code> and <code>b : t2 t</code> yield <code>polyeq a b = true</code>, then <code>let a' : t2 t = Obj.magic a</code> and <code>let b' : t1 t = Obj.magic b</code> must be safe.</p><p>Examples of safe implementations include:</p><ul><li><p>Having a type <code>'a t</code> which doesn't depend on <code>'a</code>, in which case casting form <code>'a t</code> to <code>'b t</code> is always safe:</p><pre class="language-ocaml"><code>type _ t = foo
let cast : type a b. a t -&gt; b t = fun x -&gt; x
let polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt; x = y</code></pre></li><li><p>Using a GADT type and examining its constructors to only return <code>true</code> when the constructors are equal:</p><pre class="language-ocaml"><code>type _ t =
    | T_Int : int -&gt; int t
    | T_Bool : bool -&gt; bool t
let polyeq : type a b. a t -&gt; b t -&gt; bool = fun x y -&gt;
    match x, y with
    | T_Int i, T_Int j -&gt; i = j (* Here type a = b = int, we can return true *)
    | T_Bool i, T_Bool j -&gt; i &amp;&amp; j (* same here, but with a = b = bool *)
    | _ -&gt; false (* never return true on heterogeneous cases. *)</code></pre></li><li><p>Using physical equality:</p><pre class="language-ocaml"><code>let polyeq a b = a == Obj.magic b</code></pre><p>While this contains an <code>Obj.magic</code>, it is still type safe (OCaml just compares the immediate values) and we can safely cast values from one type to the other if they satisfy this (since they are already physically equal).</p><p>This is the implementation used in <a href="../../HashedValue/index.html"><code>HashedValue</code></a>. Note however that using this function can lead to <b>identifiers no longer being unique across types</b>. They will still be unique and behave as expected within a certain type, but since some values of different types can physically equal, we may have identifer clashes:</p><pre class="language-ocaml"><code># 97 == Obj.magic 'a';;
- : bool = true</code></pre><pre class="language-ocaml"><code>module HMap = MakeHashconsedMap(struct
    type t = int
    let to_int x = x
end)(HashedValue)()</code></pre><pre class="language-ocaml"><code># let m1 = HMap.singleton 5 97;;
val m1 : int HMap.t = &lt;abstr&gt;
# let m2 = HMap.singleton 5 'a';;
val m2 : char HMap.t = &lt;abstr&gt;
# HMap.to_int m1 = HMap.to_int m2;;
- : bool = true</code></pre><p>This can cause problems if you wish to use identifiers of different map types together:</p><pre class="language-ocaml"><code>type any = Any : 'a HMap.t -&gt; any
module MapOfMaps = MakeMap(struct
  type t = any
  let to_int (Any x) = HMap.to_int x
end)</code></pre><p>Using this can lead to unexpected behaviors: in the following <code>m3</code> has cardinal 1, the <code>m1-&gt;&quot;foo&quot;</code> binding has been overwritten</p><pre class="language-ocaml"><code># let m3 = MapOfMaps.of_list [ (Any m1, &quot;foo&quot;); (Any m2, &quot;bar&quot;) ]
val m3 : string MapOfMaps.t = &lt;abstr&gt;
# MapOfMaps.to_list m3
- : (any * string) list = [(Any &lt;abstr&gt;, &quot;bar&quot;)]</code></pre><p>This issue does not happen with the two previous variants, since they both only return true on the same types.</p></li></ul></div></div></div></body></html>
