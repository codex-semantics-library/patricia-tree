<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>HashconsedSetNode (patricia-tree.PatriciaTree.HashconsedSetNode)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">patricia-tree</a> &#x00BB; <a href="../index.html">PatriciaTree</a> &#x00BB; HashconsedSetNode</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>PatriciaTree.HashconsedSetNode</span></code></h1><p>Both a <a href="../HashconsedNode/index.html"><code>HashconsedNode</code></a> and a <a href="../SetNode/index.html"><code>SetNode</code></a>.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> v0.10.0</li></ul></header><nav class="odoc-toc"><ul><li><a href="#parameters">Parameters</a></li><li><a href="#signature">Signature</a></li></ul></nav><div class="odoc-content"><h2 id="parameters"><a href="#parameters" class="anchor"></a>Parameters</h2><div class="odoc-spec"><div class="spec parameter anchored" id="argument-1-Key"><a href="#argument-1-Key" class="anchor"></a><code><span><span class="keyword">module</span> </span><span><a href="argument-1-Key/index.html">Key</a></span><span> : <a href="../module-type-HETEROGENEOUS_KEY/index.html">HETEROGENEOUS_KEY</a></span></code></div></div><h2 id="signature"><a href="#signature" class="anchor"></a>Signature</h2><div class="odoc-include"><details><summary class="spec include"><code><span><span class="keyword">include</span> <a href="../module-type-NODE/index.html">NODE</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-NODE/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="argument-1-Key/index.html#type-t">Key.t</a></span></span> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>('key, 'map) <a href="../module-type-NODE/index.html#type-value">value</a></span> = unit</span></span></code></summary><h3 id="types"><a href="#types" class="anchor"></a>Types</h3><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a key</span></span><span> = <span><span class="type-var">'a</span> <a href="argument-1-Key/index.html#type-t">Key.t</a></span></span></code></div><div class="spec-doc"><p>The type of keys.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> <span>('key, 'map) value</span></span><span> = unit</span></code></div><div class="spec-doc"><p>The type of value, which depends on the type of the key and the type of the map.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map t</span></span></code></div><div class="spec-doc"><p>The type of the map, which is parameterized by a type.</p></div></div><h3 id="constructors:-build-values"><a href="#constructors:-build-values" class="anchor"></a>Constructors: build values</h3><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty map</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-leaf"><a href="#val-leaf" class="anchor"></a><code><span><span class="keyword">val</span> leaf : <span><span><span class="type-var">'key</span> <a href="#type-key">key</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A singleton leaf, similar to <a href="../module-type-BASE_MAP/index.html#val-singleton"><code>BASE_MAP.singleton</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-branch"><a href="#val-branch" class="anchor"></a><code><span><span class="keyword">val</span> branch : 
  <span><span class="label">prefix</span>:<a href="../index.html#type-intkey">intkey</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">branching_bit</span>:<a href="../index.html#type-mask">mask</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">tree0</span>:<span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">tree1</span>:<span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'map</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>A branch node. <b>This shouldn't be called externally unless you know what you're doing!</b> Doing so could easily break the data structure's invariants.</p><p>When called, it assumes that:</p><ul><li>Neither <code>tree0</code> nor <code>tree1</code> should be empty.</li><li><code>branching_bit</code> should have a single bit set</li><li><code>prefix</code> should be normalized (bits below <code>branching_bit</code> set to zero)</li><li>All elements of <code>tree0</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li><li>All elements of <code>tree1</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li></ul></div></div><h3 id="destructors:-access-the-value"><a href="#destructors:-access-the-value" class="anchor"></a>Destructors: access the value</h3><div class="odoc-spec"><div class="spec type anchored" id="type-view"><a href="#type-view" class="anchor"></a><code><span><span class="keyword">type</span> <span>'map view</span></span><span> = <span class="keyword">private</span> </span></code><ol><li id="type-view.Empty" class="def variant constructor anchored"><a href="#type-view.Empty" class="anchor"></a><code><span>| </span><span><span class="constructor">Empty</span> : <span><span class="type-var">'map</span> <a href="#type-view">view</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Can happen only at the toplevel: there is no empty interior node.</p><span class="comment-delim">*)</span></div></li><li id="type-view.Branch" class="def variant constructor anchored"><a href="#type-view.Branch" class="anchor"></a><code><span>| </span><span><span class="constructor">Branch</span> : </span><span>{</span></code><ol><li id="type-view.prefix" class="def record field anchored"><a href="#type-view.prefix" class="anchor"></a><code><span>prefix : <a href="../index.html#type-intkey">intkey</a>;</span></code></li><li id="type-view.branching_bit" class="def record field anchored"><a href="#type-view.branching_bit" class="anchor"></a><code><span>branching_bit : <a href="../index.html#type-mask">mask</a>;</span></code></li><li id="type-view.tree0" class="def record field anchored"><a href="#type-view.tree0" class="anchor"></a><code><span>tree0 : <span><span class="type-var">'map</span> <a href="#type-t">t</a></span>;</span></code></li><li id="type-view.tree1" class="def record field anchored"><a href="#type-view.tree1" class="anchor"></a><code><span>tree1 : <span><span class="type-var">'map</span> <a href="#type-t">t</a></span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'map</span> <a href="#type-view">view</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Same constraints as <a href="#val-branch"><code>branch</code></a>:</p><ul><li><code>branching_bit</code> contains only one bit set; the corresponding mask is (branching_bit - 1).</li><li><code>prefix</code> is normalized: the bits below the <code>branching_bit</code> are set to zero (i.e. <code>prefix &amp; (branching_bit - 1) = 0</code>).</li><li>All elements of <code>tree0</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li><li>All elements of <code>tree1</code> should have their <code>to_int</code> start by <code>prefix</code> followed by 0 at position <code>branching_bit</code>).</li></ul><span class="comment-delim">*)</span></div></li><li id="type-view.Leaf" class="def variant constructor anchored"><a href="#type-view.Leaf" class="anchor"></a><code><span>| </span><span><span class="constructor">Leaf</span> : </span><span>{</span></code><ol><li id="type-view.key" class="def record field anchored"><a href="#type-view.key" class="anchor"></a><code><span>key : <span><span class="type-var">'key</span> <a href="#type-key">key</a></span>;</span></code></li><li id="type-view.value" class="def record field anchored"><a href="#type-view.value" class="anchor"></a><code><span>value : <span><span>(<span class="type-var">'key</span>, <span class="type-var">'map</span>)</span> <a href="#type-value">value</a></span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'map</span> <a href="#type-view">view</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A key -&gt; value mapping.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>This makes the map nodes accessible to the pattern matching algorithm; this corresponds 1:1 to the <a href="../SimpleNode/index.html"><code>SimpleNode</code></a> implementation. This just needs to be copy-and-pasted for every node type.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'map</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Check if the map is empty. Should be constant time.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-view"><a href="#val-view" class="anchor"></a><code><span><span class="keyword">val</span> view : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-view">view</a></span></span></code></div><div class="spec-doc"><p>Convert the map to a view. Should be constant time.</p></div></div></details></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_int"><a href="#val-to_int" class="anchor"></a><code><span><span class="keyword">val</span> to_int : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Returns a unique number for each map, the <a href="../index.html#hash_consed" title="hash_consed">hash-consed</a> identifier of the map. Unlike <a href="../module-type-NODE_WITH_ID/index.html#val-to_int"><code>NODE_WITH_ID.to_int</code></a>, hash-consing ensures that maps which contain the same keys (compared by <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>) and values (compared by <a href="../module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a>) will always be physically equal and have the same identifier.</p><p>Maps with the same identifier are also physically equal: <code>to_int m1 = to_int m2</code> implies <code>m1 == m2</code>.</p><p>Note that when using physical equality as <a href="../module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a>, some maps of different types <code>a t</code> and <code>b t</code> may be given the same identifier. See the end of the documentation of <a href="../module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a> for details.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Constant time equality using the <a href="../index.html#hash_consed" title="hash_consed">hash-consed</a> nodes identifiers. This is equivalent to physical equality. Two nodes are equal if their trees contain the same bindings, where keys are compared by <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a> and values are compared by <a href="../module-type-HASHED_VALUE/index.html#val-polyeq"><code>HASHED_VALUE.polyeq</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Constant time comparison using the <a href="../index.html#hash_consed" title="hash_consed">hash-consed</a> node identifiers. This order is fully arbitrary, but it is total and can be used to sort nodes. It is based on node ids which depend on the order in which the nodes where created (older nodes having smaller ids).</p><p>One useful property of this order is that child nodes will always have a smaller identifier than their parents.</p></div></div></div></body></html>
