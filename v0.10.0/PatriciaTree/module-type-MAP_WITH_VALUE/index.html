<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>MAP_WITH_VALUE (patricia-tree.PatriciaTree.MAP_WITH_VALUE)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">patricia-tree</a> &#x00BB; <a href="../index.html">PatriciaTree</a> &#x00BB; MAP_WITH_VALUE</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module type <code><span>PatriciaTree.MAP_WITH_VALUE</span></code></h1><p>The signature for maps with a single type for keys and values, a <code>'a map</code> binds <code>key</code> to <code>'a value</code>. This is slightly more generic than <a href="../module-type-MAP/index.html"><code>MAP</code></a>, which just binds to <code>'a</code>. It is used for maps that need to restrict their value type, namely <a href="../index.html#hash_consed" title="hash_consed">Hash-consed maps and sets</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#basic-functions">Basic functions</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#operations-on-pairs-of-maps">Operations on pairs of maps</a></li><li><a href="#conversion-functions">Conversion functions</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> key</span></code></div><div class="spec-doc"><p>The type of keys.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>A map from <code>key</code> to values of type <code>'a value</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-value"><a href="#type-value" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a value</span></span></code></div><div class="spec-doc"><p>Type for values, this is a divergence from Stdlib's <code>Map</code>, but becomes equivalent to it when using <a href="../module-type-MAP/index.html"><code>MAP</code></a>, which is just <code>MAP_WITH_VALUE with type 'a value = 'a</code>. On the other hand, it allows defining maps with fixed values, which is useful for hash-consing.</p><ul class="at-tags"><li class="since"><span class="at-tag">since</span> v0.10.0</li></ul></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-BaseMap"><a href="#module-BaseMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="BaseMap/index.html">BaseMap</a></span><span> : 
  <a href="../module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a>
    <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-t">t</a></span> = <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>_ <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-key">key</a></span> = <a href="#type-key">key</a></span>
     <span class="keyword">and</span> <span><span class="keyword">type</span> <span>('a, 'b) <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-value">value</a></span> = <span><span>(<span class="type-var">'a</span>, <span><span class="type-var">'b</span> <a href="#type-value">value</a></span>)</span> <a href="../index.html#type-snd">snd</a></span></span></span></code></div><div class="spec-doc"><p>Underlying basemap, for cross map/set operations</p></div></div><h4 id="basic-functions"><a href="#basic-functions" class="anchor"></a>Basic functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>The empty map.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Test if a map is empty; O(1) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsigned_min_binding"><a href="#val-unsigned_min_binding" class="anchor"></a><code><span><span class="keyword">val</span> unsigned_min_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span></span></code></div><div class="spec-doc"><p>Returns the <code>(key,value)</code> pair where <code>Key.to_int key</code> is minimal (in the <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned representation</a> of integers); O(log n) complexity.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the map is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-unsigned_max_binding"><a href="#val-unsigned_max_binding" class="anchor"></a><code><span><span class="keyword">val</span> unsigned_max_binding : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span></span></code></div><div class="spec-doc"><p>Returns the <code>(key,value)</code> pair where <code>Key.to_int key</code> is maximal (in the <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned representation</a> of integers); O(log n) complexity.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> <p>if the map is empty.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>singleton key value</code> creates a map with a single binding, O(1) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span><span class="keyword">val</span> cardinal : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The size of the map. O(n) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_singleton"><a href="#val-is_singleton" class="anchor"></a><code><span><span class="keyword">val</span> is_singleton : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>is_singleton m</code> is <code>Some (k,v)</code> iff <code>m</code> is <code>singleton k v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find"><a href="#val-find" class="anchor"></a><code><span><span class="keyword">val</span> find : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-value">value</a></span></span></code></div><div class="spec-doc"><p>Return an element in the map, or raise <code>Not_found</code>, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-find_opt"><a href="#val-find_opt" class="anchor"></a><code><span><span class="keyword">val</span> find_opt : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span></span></code></div><div class="spec-doc"><p>Return an element in the map, or <code>None</code>, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem key map</code> returns <code>true</code> if and only if <code>key</code> is bound in <code>map</code>. O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns a map with the element removed, O(log(n)) complexity. Returns a physically equal map if the element is absent.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_unsigned_minimum"><a href="#val-pop_unsigned_minimum" class="anchor"></a><code><span><span class="keyword">val</span> pop_unsigned_minimum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_unsigned_minimum m</code> returns <code>None</code> if <code>is_empty m</code>, or <code>Some(key,value,m')</code> where <code>(key,value) = unsigned_min_binding m</code> and <code>m' = remove m key</code>. O(log(n)) complexity. Uses the <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_unsigned_maximum"><a href="#val-pop_unsigned_maximum" class="anchor"></a><code><span><span class="keyword">val</span> pop_unsigned_maximum : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_unsigned_maximum m</code> returns <code>None</code> if <code>is_empty m</code>, or <code>Some(key,value,m')</code> where <code>(key,value) = unsigned_max_binding m</code> and <code>m' = remove m key</code>. O(log(n)) complexity. Uses the <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-insert"><a href="#val-insert" class="anchor"></a><code><span><span class="keyword">val</span> insert : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>insert key f map</code> modifies or insert an element of the map; <code>f</code> takes <code>None</code> if the value was not previously bound, and <code>Some old</code> where <code>old</code> is the previously bound value otherwise. The function preserves physical equality when possible. O(log(n)) complexity. Preserves physical equality if the new value is physically equal to the old.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update key f map</code> modifies, insert, or remove an element from the map; <code>f</code> takes <code>None</code> if the value was not previously bound, and <code>Some old</code> where <code>old</code> is the previously bound value otherwise. The function preserves physical equality when possible. It returns None if the element should be removed O(log(n)) complexity. Preserves physical equality if the new value is physically equal to the old.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Unconditionally adds a value in the map (independently from whether the old value existed). O(log(n)) complexity. Preserves physical equality if the new value is physically equal to the old.</p></div></div><h4 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h4><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span> * <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span> * <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>split key map</code> splits the map into:</p><ul><li>submap of <code>map</code> whose keys are smaller than <code>key</code></li><li>value associated to <code>key</code> (if present)</li><li>submap of <code>map</code> whose keys are bigger than <code>key</code></li></ul><p>Uses the <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> on <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate on each <code>(key,value)</code> pair of the map, in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p>Fold on each <code>(key,value)</code> pair of the map, in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_on_nonequal_inter"><a href="#val-fold_on_nonequal_inter" class="anchor"></a><code><span><span class="keyword">val</span> fold_on_nonequal_inter : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold_on_nonequal_inter f m1 m2 acc</code> returns <code>f key_n value1_n value2n (... (f key_1 value1_1 value2_1 acc))</code> where <code>(key_1, value1_1, value2_1) ... (key_n, value1_n, value2_n)</code> are the bindings that exist in both maps (<code>m1 âˆ© m2</code>) whose values are physically different. Calls to <code>f</code> are performed in the <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold_on_nonequal_union"><a href="#val-fold_on_nonequal_union" class="anchor"></a><code><span><span class="keyword">val</span> fold_on_nonequal_union : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold_on_nonequal_union f m1 m2 acc</code> returns <code>f key_n value1_n value2n (... (f key_1 value1_1 value2_1 acc))</code> where <code>(key_1, value1_1, value2_1) ... (key_n, value1_n, value2_n)</code> are the bindings that exists in either map (<code>m1 âˆª m2</code>) whose values are physically different. Calls to <code>f.f</code> are performed in the <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p>Returns the submap containing only the key-&gt;value pairs satisfying the given predicate. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if the predicate holds on all map bindings. Short-circuiting. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><p>In the following, the *no_share function allows taking arguments of different types (but cannot share subtrees of the map), while the default functions attempt to preserve and benefit from sharing the subtrees (using physical equality to detect sharing).</p><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f value</code>. The subtrees for which the returned value is physically the same (i.e. <code>f key value == value</code> for all the keys in the subtree) are guaranteed to be physically equal to the original subtree. O(n) complexity. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map_no_share"><a href="#val-map_no_share" class="anchor"></a><code><span><span class="keyword">val</span> map_no_share : <span><span>(<span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map_no_share f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f value</code>. O(n) complexity. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span><span class="keyword">val</span> mapi : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mapi f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f key value</code>. The subtrees for which the returned value is physically the same (i.e. <code>f key value == value</code> for all the keys in the subtree) are guaranteed to be physically equal to the original subtree. O(n) complexity. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mapi_no_share"><a href="#val-mapi_no_share" class="anchor"></a><code><span><span class="keyword">val</span> mapi_no_share : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>mapi_no_share f m</code> returns a map where the <code>value</code> bound to each <code>key</code> is replaced by <code>f key value</code>. O(n) complexity. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map"><a href="#val-filter_map" class="anchor"></a><code><span><span class="keyword">val</span> filter_map : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map m f</code> returns a map where the <code>value</code> bound to each <code>key</code> is removed (if <code>f key value</code> returns <code>None</code>), or is replaced by <code>v</code> ((if <code>f key value</code> returns <code>Some v</code>). The subtrees for which the returned value is physically the same (i.e. <code>f key value = Some v</code> with <code>value == v</code> for all the keys in the subtree) are guaranteed to be physically equal to the original subtree. O(n) complexity. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter_map_no_share"><a href="#val-filter_map_no_share" class="anchor"></a><code><span><span class="keyword">val</span> filter_map_no_share : <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-value">value</a></span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>filter_map m f</code> returns a map where the <code>value</code> bound to each <code>key</code> is removed (if <code>f key value</code> returns <code>None</code>), or is replaced by <code>v</code> ((if <code>f key value</code> returns <code>Some v</code>). O(n) complexity. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>.</p></div></div><h4 id="operations-on-pairs-of-maps"><a href="#operations-on-pairs-of-maps" class="anchor"></a>Operations on pairs of maps</h4><p>The following functions combine two maps. It is key for the performance, when we have large maps who share common subtrees, not to visit the nodes in these subtrees. Hence, we have specialized versions of these functions that assume properties of the function parameter (reflexive relation, idempotent operation, etc.)</p><p>When we cannot enjoy these properties, our functions explicitly say so (with a nonreflexive or nonidempotent prefix). The names are a bit long, but having these names avoids using an ineffective code by default, by forcing to know and choose between the fast and slow version.</p><p>It is also important to not visit a subtree when there merging this subtree with Empty; hence we provide union and inter operations.</p><div class="odoc-spec"><div class="spec value anchored" id="val-reflexive_same_domain_for_all2"><a href="#val-reflexive_same_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> reflexive_same_domain_for_all2 : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>reflexive_same_domain_for_all2 f map1 map2</code> returns <code>true</code> if <code>map1</code> and <code>map2</code> have the same keys, and <code>f key value1 value2</code> returns true for each mapping pair of keys. We assume that <code>f</code> is reflexive (i.e. <code>f key value value</code> returns <code>true</code>) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nonreflexive_same_domain_for_all2"><a href="#val-nonreflexive_same_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> nonreflexive_same_domain_for_all2 : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>nonreflexive_same_domain_for_all2 f map1 map2</code> returns true if map1 and map2 have the same keys, and <code>f key value1 value2</code> returns true for each mapping pair of keys. The complexity is O(min(|map1|,|map2|)).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-reflexive_subset_domain_for_all2"><a href="#val-reflexive_subset_domain_for_all2" class="anchor"></a><code><span><span class="keyword">val</span> reflexive_subset_domain_for_all2 : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> bool)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div><div class="spec-doc"><p><code>reflexive_subset_domain_for_all2 f map1 map2</code> returns true if all the keys of <code>map1</code> also are in <code>map2</code>, and <code>f key (find map1
      key) (find map2 key)</code> returns <code>true</code> when both keys are present in the map. We assume that <code>f</code> is reflexive (i.e. <code>f key value
      value</code> returns true) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_union"><a href="#val-idempotent_union" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_union : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_union f map1 map2</code> returns a map whose keys is the union of the keys of <code>map1</code> and <code>map2</code>. <code>f</code> is used to combine the values a key is mapped in both maps. We assume that <code>f</code> is idempotent (i.e. <code>f key value value == value</code>) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>, and also to preserve physical equality of the subtreess in that case. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. <code>f</code> is never called on physically equal values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_inter"><a href="#val-idempotent_inter" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_inter : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_inter f map1 map2</code> returns a map whose keys is the intersection of the keys of <code>map1</code> and <code>map2</code>. <code>f</code> is used to combine the values a key is mapped in both maps. We assume that <code>f</code> is idempotent (i.e. <code>f key value value == value</code>) to avoid visiting physically equal subtrees of <code>map1</code> and <code>map2</code>, and also to preserve physical equality of the subtrees in that case. The complexity is O(log(n)*Delta) where Delta is the number of different keys between <code>map1</code> and <code>map2</code>. <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>!. <code>f</code> is never called on physically equal values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-nonidempotent_inter_no_share"><a href="#val-nonidempotent_inter_no_share" class="anchor"></a><code><span><span class="keyword">val</span> nonidempotent_inter_no_share : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'c</span> <a href="#type-value">value</a></span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>nonidempotent_inter_no_share f map1 map2</code> returns a map whose keys is the intersection of the keys of <code>map1</code> and <code>map2</code>. <code>f</code> is used to combine the values a key is mapped in both maps. <code>f</code> does not need to be idempotent, which imply that we have to visit physically equal subtrees of <code>map1</code> and <code>map2</code>. The complexity is O(log(n)*min(|map1|,|map2|)). <code>f</code> is called in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a>. <code>f</code> is called on every shared binding.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-idempotent_inter_filter"><a href="#val-idempotent_inter_filter" class="anchor"></a><code><span><span class="keyword">val</span> idempotent_inter_filter : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>idempotent_inter_filter f m1 m2</code> is like <a href="#val-idempotent_inter"><code>idempotent_inter</code></a> (assuming idempotence, using and preserving physically equal subtrees), but it also removes the key-&gt;value bindings for which <code>f</code> returns <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-slow_merge"><a href="#val-slow_merge" class="anchor"></a><code><span><span class="keyword">val</span> slow_merge : 
  <span><span>(<span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span><span class="type-var">'b</span> <a href="#type-value">value</a></span> option</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'c</span> <a href="#type-value">value</a></span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'c</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>slow_merge f m1 m2</code> returns a map whose keys are a subset of the keys of <code>m1</code> and <code>m2</code>. The <code>f</code> function is used to combine keys, similarly to the <code>Map.merge</code> function. This funcion has to traverse all the bindings in <code>m1</code> and <code>m2</code>; its complexity is O(|m1|+|m2|). Use one of faster functions above if you can.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-disjoint"><a href="#val-disjoint" class="anchor"></a><code><span><span class="keyword">val</span> disjoint : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-WithForeign"><a href="#module-WithForeign" class="anchor"></a><code><span><span class="keyword">module</span> <a href="WithForeign/index.html">WithForeign</a></span><span> (<a href="WithForeign/argument-1-Map2/index.html">Map2</a> : <a href="../module-type-BASE_MAP/index.html">BASE_MAP</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>_ <a href="../module-type-BASE_MAP/index.html#type-key">key</a></span> = <a href="#type-key">key</a></span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Combination with other kinds of maps. <code>Map2</code> must use the same <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a> function.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty"><a href="#val-pretty" class="anchor"></a><code><span><span class="keyword">val</span> pretty : 
  <span><span class="optlabel">?pp_sep</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-key">key</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-value">value</a></span> <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Pretty prints all bindings of the map. <code>pp_sep</code> is called once between each binding pair and defaults to <a href="https://v2.ocaml.org/api/Format.html#VALpp_print_cut"><code>Format.pp_print_cut</code></a>.</p></div></div><h4 id="conversion-functions"><a href="#conversion-functions" class="anchor"></a>Conversion functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq m</code> iterates the whole map, in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_rev_seq"><a href="#val-to_rev_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_seq : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_rev_seq m</code> iterates the whole map, in decreasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>add_seq s m</code> adds all bindings of the sequence <code>s</code> to <code>m</code> in order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_seq s</code> creates a new map from the bindings of <code>s</code>. If a key is bound multiple times in <code>s</code>, the latest binding is kept</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_list l</code> creates a new map from the bindings of <code>l</code>. If a key is bound multiple times in <code>l</code>, the latest binding is kept</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-key">key</a> * <span><span class="type-var">'a</span> <a href="#type-value">value</a></span>)</span> list</span></span></code></div><div class="spec-doc"><p><code>to_list m</code> returns the bindings of <code>m</code> as a list, in increasing <a href="../index.html#val-unsigned_lt" title="unsigned_lt">unsigned order</a> of <a href="../module-type-KEY/index.html#val-to_int"><code>KEY.to_int</code></a></p></div></div></div></body></html>
