<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>HETEROGENEOUS_SET (patricia-tree.PatriciaTree.HETEROGENEOUS_SET)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">patricia-tree</a> &#x00BB; <a href="../index.html">PatriciaTree</a> &#x00BB; HETEROGENEOUS_SET</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module type <code><span>PatriciaTree.HETEROGENEOUS_SET</span></code></h1><p>A set containing different keys, very similar to <a href="../module-type-SET/index.html"><code>SET</code></a>, but with simple type <code>elt</code> being replaced by type constructor <code>'a elt</code>.</p></header><nav class="odoc-toc"><ul><li><a href="#basic-functions">Basic functions</a></li><li><a href="#functions-on-pairs-of-sets">Functions on pairs of sets</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#conversion-functions">Conversion functions</a></li></ul></nav><div class="odoc-content"><p>The main changes from <a href="../module-type-SET/index.html"><code>SET</code></a> are:</p><ul><li>The type of <a href="#type-elt"><code>elt</code></a> is replaced by a type constructor <code>'k elt</code>. Because of that, most higher-order arguments require higher-ranking polymorphism, and we provide records that allows to pass them as arguments (e.g. <a href="#type-polyfold"><code>polyfold</code></a>, <a href="#type-polypretty"><code>polypretty</code></a>, etc.)</li><li>The type of some return values, must be concealed existentially, hence the <a href="#type-any_elt.Any"><code>Any</code></a> constructor.</li></ul><div class="odoc-spec"><div class="spec type anchored" id="type-elt"><a href="#type-elt" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a elt</span></span></code></div><div class="spec-doc"><p>Elements of the set</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-BaseMap"><a href="#module-BaseMap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="BaseMap/index.html">BaseMap</a></span><span> : 
  <a href="../module-type-HETEROGENEOUS_MAP/index.html">HETEROGENEOUS_MAP</a> <span class="keyword">with</span> <span><span class="keyword">type</span> <span>'a <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-key">key</a></span> = <span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span></span> <span class="keyword">and</span> <span><span class="keyword">type</span> <span>(_, _) <a href="../module-type-HETEROGENEOUS_MAP/index.html#type-value">value</a></span> = unit</span></span></code></div><div class="spec-doc"><p>Underlying basemap, for cross map/set operations</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span>unit <a href="BaseMap/index.html#type-t">BaseMap.t</a></span></span></code></div><div class="spec-doc"><p>The type of our set</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-key"><a href="#type-key" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a key</span></span><span> = <span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span></span></code></div><div class="spec-doc"><p>Alias for elements, for compatibility with other PatriciaTrees</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-any_elt"><a href="#type-any_elt" class="anchor"></a><code><span><span class="keyword">type</span> any_elt</span><span> = </span></code><ol><li id="type-any_elt.Any" class="def variant constructor anchored"><a href="#type-any_elt.Any" class="anchor"></a><code><span>| </span><span><span class="constructor">Any</span> : <span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-any_elt">any_elt</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Existential wrapper for keys</p><span class="comment-delim">*)</span></div></li></ol></div></div><h4 id="basic-functions"><a href="#basic-functions" class="anchor"></a>Basic functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The empty set</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_empty"><a href="#val-is_empty" class="anchor"></a><code><span><span class="keyword">val</span> is_empty : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_empty st</code> is <code>true</code> if <code>st</code> contains no elements, <code>false</code> otherwise</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-mem"><a href="#val-mem" class="anchor"></a><code><span><span class="keyword">val</span> mem : <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>mem elt set</code> is <code>true</code> if <code>elt</code> is contained in <code>set</code>, O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add elt set</code> adds element <code>elt</code> to the <code>set</code>. Preserves physical equality if <code>elt</code> was already present. O(log(n)) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span><span class="keyword">val</span> singleton : <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>singleton elt</code> returns a set containing a single element: <code>elt</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cardinal"><a href="#val-cardinal" class="anchor"></a><code><span><span class="keyword">val</span> cardinal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>the size of the set (number of elements), O(n) complexity.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_singleton"><a href="#val-is_singleton" class="anchor"></a><code><span><span class="keyword">val</span> is_singleton : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-any_elt">any_elt</a> option</span></span></code></div><div class="spec-doc"><p><code>is_singleton set</code> is <code>Some (Any elt)</code> if <code>set</code> is <code>singleton elt</code> and <code>None</code> otherwise.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span><span class="keyword">val</span> remove : <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>remove elt set</code> returns a set containing all elements of <code>set</code> except <code>elt</code>. Returns a value physically equal to <code>set</code> if <code>elt</code> is not present.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-min_elt"><a href="#val-min_elt" class="anchor"></a><code><span><span class="keyword">val</span> min_elt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-any_elt">any_elt</a></span></code></div><div class="spec-doc"><p>The minimal element if non empty.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> </li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-max_elt"><a href="#val-max_elt" class="anchor"></a><code><span><span class="keyword">val</span> max_elt : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-any_elt">any_elt</a></span></code></div><div class="spec-doc"><p>The maximal element if non empty.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <code>Not_found</code> </li></ul></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_minimum"><a href="#val-pop_minimum" class="anchor"></a><code><span><span class="keyword">val</span> pop_minimum : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-any_elt">any_elt</a> * <a href="#type-t">t</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_minimum s</code> is <code>Some (elt, s')</code> where <code>elt = min_elt s</code> and <code>s' = remove elt s</code> if <code>s</code> is non empty.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pop_maximum"><a href="#val-pop_maximum" class="anchor"></a><code><span><span class="keyword">val</span> pop_maximum : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="#type-any_elt">any_elt</a> * <a href="#type-t">t</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>pop_maximum s</code> is <code>Some (elt, s')</code> where <code>elt = max_elt s</code> and <code>s' = remove elt s</code> if <code>s</code> is non empty.</p></div></div><h4 id="functions-on-pairs-of-sets"><a href="#functions-on-pairs-of-sets" class="anchor"></a>Functions on pairs of sets</h4><div class="odoc-spec"><div class="spec value anchored" id="val-union"><a href="#val-union" class="anchor"></a><code><span><span class="keyword">val</span> union : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>union a b</code> is the set union of <code>a</code> and <code>b</code>, i.e. the set containing all elements that are either in <code>a</code> or <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-inter"><a href="#val-inter" class="anchor"></a><code><span><span class="keyword">val</span> inter : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>inter a b</code> is the set intersection of <code>a</code> and <code>b</code>, i.e. the set containing all elements that are in both <code>a</code> or <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-disjoint"><a href="#val-disjoint" class="anchor"></a><code><span><span class="keyword">val</span> disjoint : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>disjoint a b</code> is <code>true</code> if <code>a</code> and <code>b</code> have no elements in common.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-equal"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>equal a b</code> is <code>true</code> if <code>a</code> and <code>b</code> contain the same elements.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span><span class="keyword">val</span> subset : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>subset a b</code> is <code>true</code> if all elements of <code>a</code> are also in <code>b</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-split"><a href="#val-split" class="anchor"></a><code><span><span class="keyword">val</span> split : <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * bool * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>split elt set</code> returns <code>s_lt, present, s_gt</code> where <code>s_lt</code> contains all elements of <code>set</code> smaller than <code>elt</code>, <code>s_gt</code> all those greater than <code>elt</code>, and <code>present</code> is <code>true</code> if <code>elt</code> is in <code>set</code>.</p></div></div><h4 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h4><div class="odoc-spec"><div class="spec type anchored" id="type-polyiter"><a href="#type-polyiter" class="anchor"></a><code><span><span class="keyword">type</span> polyiter</span><span> = </span><span>{</span></code><ol><li id="type-polyiter.f" class="def record field anchored"><a href="#type-polyiter.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span><span class="keyword">val</span> iter : <span><a href="#type-polyiter">polyiter</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>iter f set</code> calls <code>f.f</code> on all elements of <code>set</code>, in order of <code>Key.to_int</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polypredicate"><a href="#type-polypredicate" class="anchor"></a><code><span><span class="keyword">type</span> polypredicate</span><span> = </span><span>{</span></code><ol><li id="type-polypredicate.f" class="def record field anchored"><a href="#type-polypredicate.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> bool;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span><span class="keyword">val</span> filter : <span><a href="#type-polypredicate">polypredicate</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>filter f set</code> is the subset of <code>set</code> that only contains the elements that satisfy <code>f.f</code>. <code>f.f</code> is called in order of <code>Key.to_int</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-for_all"><a href="#val-for_all" class="anchor"></a><code><span><span class="keyword">val</span> for_all : <span><a href="#type-polypredicate">polypredicate</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>for_all f set</code> is <code>true</code> if <code>f.f</code> is <code>true</code> on all elements of <code>set</code>. Short-circuits on first <code>false</code>. <code>f.f</code> is called in order of <code>Key.to_int</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polyfold"><a href="#type-polyfold" class="anchor"></a><code><span><span class="keyword">type</span> <span>'acc polyfold</span></span><span> = </span><span>{</span></code><ol><li id="type-polyfold.f" class="def record field anchored"><a href="#type-polyfold.f" class="anchor"></a><code><span>f : 'a. <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span><span class="keyword">val</span> fold : <span><span><span class="type-var">'acc</span> <a href="#type-polyfold">polyfold</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'acc</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'acc</span></span></code></div><div class="spec-doc"><p><code>fold f set acc</code> returns <code>f.f elt_n (... (f.f elt_1 acc) ...)</code>, where <code>elt_1, ..., elt_n</code> are the elements of <code>set</code>, in increasing order of <code>Key.to_int</code></p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-polypretty"><a href="#type-polypretty" class="anchor"></a><code><span><span class="keyword">type</span> polypretty</span><span> = </span><span>{</span></code><ol><li id="type-polypretty.f" class="def record field anchored"><a href="#type-polypretty.f" class="anchor"></a><code><span>f : 'a. <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-elt">elt</a></span> <span class="arrow">&#45;&gt;</span></span> unit;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-pretty"><a href="#val-pretty" class="anchor"></a><code><span><span class="keyword">val</span> pretty : 
  <span><span class="optlabel">?pp_sep</span>:<span>(<span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-polypretty">polypretty</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Pretty prints the set, <code>pp_sep</code> is called once between each element, it defaults to <code>Format.pp_print_cut</code></p></div></div><h4 id="conversion-functions"><a href="#conversion-functions" class="anchor"></a>Conversion functions</h4><div class="odoc-spec"><div class="spec value anchored" id="val-to_seq"><a href="#val-to_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-any_elt">any_elt</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_seq st</code> iterates the whole set, in increasing order of <code>Key.to_int</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_rev_seq"><a href="#val-to_rev_seq" class="anchor"></a><code><span><span class="keyword">val</span> to_rev_seq : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-any_elt">any_elt</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>to_rev_seq st</code> iterates the whole set, in decreasing order of <code>Key.to_int</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-add_seq"><a href="#val-add_seq" class="anchor"></a><code><span><span class="keyword">val</span> add_seq : <span><span><a href="#type-any_elt">any_elt</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_seq s st</code> adds all elements of the sequence <code>s</code> to <code>st</code> in order.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : <span><span><a href="#type-any_elt">any_elt</a> <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_seq s</code> creates a new set from the elements of <code>s</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span><span class="keyword">val</span> of_list : <span><span><a href="#type-any_elt">any_elt</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_list l</code> creates a new set from the elements of <code>l</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span><span class="keyword">val</span> to_list : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-any_elt">any_elt</a> list</span></span></code></div><div class="spec-doc"><p><code>to_list s</code> returns the elements of <code>s</code> as a list, in increasing order of <code>Key.to_int</code></p></div></div></div></body></html>
